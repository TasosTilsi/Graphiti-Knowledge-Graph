"""Hook installation logic for git and Claude Code.

Provides non-destructive installation of capture hooks with marker-based detection
for idempotent and reversible operations.
"""

import json
from pathlib import Path
from typing import Optional

import structlog

logger = structlog.get_logger(__name__)

HOOK_START_MARKER = "# GRAPHITI_HOOK_START"
HOOK_END_MARKER = "# GRAPHITI_HOOK_END"


def _get_hook_template(hook_type: str = "post-commit") -> str:
    """Read a hook template from the templates directory.

    Args:
        hook_type: Hook type (post-commit, pre-commit, post-merge)

    Returns:
        Template content as string

    Raises:
        FileNotFoundError: If template file doesn't exist
    """
    template_path = Path(__file__).parent / "templates" / f"{hook_type}.sh"
    return template_path.read_text()


def _get_graphiti_section(hook_type: str = "post-commit") -> str:
    """Extract the graphiti section (between markers) from the template.

    Args:
        hook_type: Hook type (post-commit, pre-commit, post-merge)

    Returns:
        Just the section between GRAPHITI_HOOK_START and GRAPHITI_HOOK_END markers (inclusive)
    """
    template = _get_hook_template(hook_type)

    # Find start and end marker positions
    start_idx = template.find(HOOK_START_MARKER)
    end_idx = template.find(HOOK_END_MARKER)

    if start_idx == -1 or end_idx == -1:
        raise ValueError("Template missing GRAPHITI_HOOK_START or GRAPHITI_HOOK_END marker")

    # Include the end marker line (find the newline after END marker)
    end_line_end = template.find('\n', end_idx)
    if end_line_end == -1:
        end_line_end = len(template)
    else:
        end_line_end += 1  # Include the newline

    return template[start_idx:end_line_end]


def is_git_hook_installed(repo_path: Path) -> bool:
    """Check if graphiti post-commit hook is already installed.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    hook_path = repo_path / ".git" / "hooks" / "post-commit"

    if not hook_path.exists():
        return False

    try:
        content = hook_path.read_text()
        return HOOK_START_MARKER in content
    except Exception as e:
        logger.warning("Failed to read hook file", path=str(hook_path), error=str(e))
        return False


def install_git_hook(repo_path: Path, force: bool = False) -> bool:
    """Install post-commit hook non-destructively.

    If an existing hook is present, appends graphiti section. If no hook exists,
    creates new hook with full template. Uses markers for idempotent detection.

    Args:
        repo_path: Path to git repository
        force: If True, reinstall even if already installed (not currently used)

    Returns:
        True if hook was installed, False if already installed

    Raises:
        ValueError: If repo_path is not a git repository
    """
    # Verify this is a git repo
    git_dir = repo_path / ".git"
    if not git_dir.exists() or not git_dir.is_dir():
        raise ValueError(f"Not a git repository: {repo_path}")

    # Check if already installed (idempotent)
    if is_git_hook_installed(repo_path):
        logger.info("Graphiti hook already installed", repo=str(repo_path))
        return False

    hook_path = git_dir / "hooks" / "post-commit"

    # Ensure hooks directory exists
    hook_path.parent.mkdir(parents=True, exist_ok=True)

    if hook_path.exists():
        # Existing hook from another tool - append our section
        logger.info("Existing post-commit hook found, appending graphiti section",
                   path=str(hook_path))

        existing_content = hook_path.read_text()

        # Detect pre-commit framework
        if "# pre-commit" in existing_content or "pre-commit hook" in existing_content:
            logger.warning(
                "pre-commit framework detected - appending graphiti hook",
                suggestion="Consider pre-commit integration for better compatibility"
            )

        # Append our section with spacing
        graphiti_section = _get_graphiti_section()
        new_content = existing_content.rstrip() + "\n\n" + graphiti_section
        hook_path.write_text(new_content)

    else:
        # No existing hook - create new one with full template
        logger.info("Creating new post-commit hook", path=str(hook_path))
        template = _get_hook_template()
        hook_path.write_text(template)

    # Set executable permission
    hook_path.chmod(0o755)

    logger.info("Graphiti post-commit hook installed successfully", repo=str(repo_path))
    return True


def uninstall_git_hook(repo_path: Path) -> bool:
    """Remove graphiti section from post-commit hook.

    If hook only contains graphiti content, removes entire file.
    If hook contains other content, removes only graphiti section.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    # Check if installed
    if not is_git_hook_installed(repo_path):
        logger.info("Graphiti hook not installed, nothing to uninstall", repo=str(repo_path))
        return False

    hook_path = repo_path / ".git" / "hooks" / "post-commit"
    content = hook_path.read_text()

    # Find graphiti section boundaries
    start_idx = content.find(HOOK_START_MARKER)
    end_idx = content.find(HOOK_END_MARKER)

    if start_idx == -1 or end_idx == -1:
        logger.error("Hook markers not found despite is_git_hook_installed check",
                    path=str(hook_path))
        return False

    # Find the end of the end marker line
    end_line_end = content.find('\n', end_idx)
    if end_line_end == -1:
        end_line_end = len(content)
    else:
        end_line_end += 1  # Include the newline

    # Extract content before and after graphiti section
    before = content[:start_idx]
    after = content[end_line_end:]

    # Remove surrounding blank lines
    before = before.rstrip()
    after = after.lstrip()

    remaining_content = before + ("\n\n" + after if after else "")
    remaining_content = remaining_content.strip()

    if not remaining_content or remaining_content == "#!/bin/sh":
        # Hook only contained graphiti content - remove entire file
        hook_path.unlink()
        logger.info("Removed entire post-commit hook (only graphiti content)",
                   path=str(hook_path))
    else:
        # Other content exists - write back without graphiti section
        hook_path.write_text(remaining_content + "\n")
        logger.info("Removed graphiti section from post-commit hook",
                   path=str(hook_path))

    return True


def install_claude_hook(project_path: Path) -> bool:
    """Create/update .claude/settings.json with Stop hook for auto-capture.

    Adds graphiti capture command to Stop hooks array with async execution.
    Project-local settings only (not global).

    Args:
        project_path: Path to project root

    Returns:
        True if hook was installed, False if already exists
    """
    settings_dir = project_path / ".claude"
    settings_path = settings_dir / "settings.json"

    # Graphiti Stop hook configuration
    graphiti_hook = {
        "command": 'graphiti capture --auto --transcript-path "$transcript_path" --session-id "$session_id"',
        "async": True,
        "timeout": 10
    }

    # Load existing settings or create new
    if settings_path.exists():
        try:
            with open(settings_path, 'r') as f:
                settings = json.load(f)
        except json.JSONDecodeError as e:
            logger.error("Failed to parse .claude/settings.json",
                        path=str(settings_path), error=str(e))
            return False
    else:
        settings = {}

    # Ensure hooks.Stop array exists
    if "hooks" not in settings:
        settings["hooks"] = {}

    if "Stop" not in settings["hooks"]:
        settings["hooks"]["Stop"] = []

    # Check if graphiti hook already exists (idempotent)
    for hook in settings["hooks"]["Stop"]:
        if isinstance(hook, dict) and "graphiti capture" in hook.get("command", ""):
            logger.info("Graphiti Claude Code hook already installed",
                       project=str(project_path))
            return False

    # Add graphiti hook
    settings["hooks"]["Stop"].append(graphiti_hook)

    # Ensure directory exists and write settings
    settings_dir.mkdir(parents=True, exist_ok=True)
    with open(settings_path, 'w') as f:
        json.dump(settings, f, indent=2)

    logger.info("Graphiti Claude Code Stop hook installed", project=str(project_path))
    return True


def uninstall_claude_hook(project_path: Path) -> bool:
    """Remove graphiti entry from .claude/settings.json hooks.Stop array.

    Args:
        project_path: Path to project root

    Returns:
        True if hook was removed, False if not installed
    """
    settings_path = project_path / ".claude" / "settings.json"

    if not settings_path.exists():
        logger.info("No .claude/settings.json found, nothing to uninstall",
                   project=str(project_path))
        return False

    try:
        with open(settings_path, 'r') as f:
            settings = json.load(f)
    except json.JSONDecodeError as e:
        logger.error("Failed to parse .claude/settings.json",
                    path=str(settings_path), error=str(e))
        return False

    # Check if graphiti hook exists
    if "hooks" not in settings or "Stop" not in settings["hooks"]:
        logger.info("No Stop hooks found, nothing to uninstall",
                   project=str(project_path))
        return False

    # Filter out graphiti hooks
    original_count = len(settings["hooks"]["Stop"])
    settings["hooks"]["Stop"] = [
        hook for hook in settings["hooks"]["Stop"]
        if not (isinstance(hook, dict) and "graphiti capture" in hook.get("command", ""))
    ]

    if len(settings["hooks"]["Stop"]) == original_count:
        logger.info("Graphiti hook not found in Stop hooks", project=str(project_path))
        return False

    # Clean up empty structures
    if not settings["hooks"]["Stop"]:
        del settings["hooks"]["Stop"]

    if not settings["hooks"]:
        del settings["hooks"]

    # Write back settings
    with open(settings_path, 'w') as f:
        json.dump(settings, f, indent=2)

    logger.info("Graphiti Claude Code hook removed", project=str(project_path))
    return True


# Generalized git hook functions for pre-commit and post-merge


def _install_hook(hook_type: str, repo_path: Path, force: bool = False) -> bool:
    """Install a git hook non-destructively (generalized helper).

    Args:
        hook_type: Hook type (pre-commit, post-merge, etc.)
        repo_path: Path to git repository
        force: If True, reinstall even if already installed

    Returns:
        True if hook was installed, False if already installed

    Raises:
        ValueError: If repo_path is not a git repository
    """
    # Verify this is a git repo
    git_dir = repo_path / ".git"
    if not git_dir.exists() or not git_dir.is_dir():
        raise ValueError(f"Not a git repository: {repo_path}")

    hook_path = git_dir / "hooks" / hook_type

    # Check if already installed (idempotent)
    if hook_path.exists():
        content = hook_path.read_text()
        if HOOK_START_MARKER in content:
            logger.info(f"Graphiti {hook_type} hook already installed", repo=str(repo_path))
            return False

    # Ensure hooks directory exists
    hook_path.parent.mkdir(parents=True, exist_ok=True)

    if hook_path.exists():
        # Existing hook from another tool - append our section
        logger.info(
            f"Existing {hook_type} hook found, appending graphiti section",
            path=str(hook_path)
        )

        existing_content = hook_path.read_text()

        # Detect pre-commit framework
        if "# pre-commit" in existing_content or "pre-commit hook" in existing_content:
            logger.warning(
                "pre-commit framework detected - appending graphiti hook",
                suggestion="Consider pre-commit integration for better compatibility"
            )

        # Append our section with spacing
        graphiti_section = _get_graphiti_section(hook_type)
        new_content = existing_content.rstrip() + "\n\n" + graphiti_section
        hook_path.write_text(new_content)

    else:
        # No existing hook - create new one with full template
        logger.info(f"Creating new {hook_type} hook", path=str(hook_path))
        template = _get_hook_template(hook_type)
        hook_path.write_text(template)

    # Set executable permission
    hook_path.chmod(0o755)

    logger.info(f"Graphiti {hook_type} hook installed successfully", repo=str(repo_path))
    return True


def _is_hook_installed(hook_type: str, repo_path: Path) -> bool:
    """Check if graphiti hook is installed (generalized helper).

    Args:
        hook_type: Hook type (pre-commit, post-merge, etc.)
        repo_path: Path to git repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    hook_path = repo_path / ".git" / "hooks" / hook_type

    if not hook_path.exists():
        return False

    try:
        content = hook_path.read_text()
        return HOOK_START_MARKER in content
    except Exception as e:
        logger.warning(f"Failed to read {hook_type} hook file", path=str(hook_path), error=str(e))
        return False


def _uninstall_hook(hook_type: str, repo_path: Path) -> bool:
    """Remove graphiti section from a git hook (generalized helper).

    Args:
        hook_type: Hook type (pre-commit, post-merge, etc.)
        repo_path: Path to git repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    # Check if installed
    if not _is_hook_installed(hook_type, repo_path):
        logger.info(f"Graphiti {hook_type} hook not installed, nothing to uninstall", repo=str(repo_path))
        return False

    hook_path = repo_path / ".git" / "hooks" / hook_type
    content = hook_path.read_text()

    # Find graphiti section boundaries
    start_idx = content.find(HOOK_START_MARKER)
    end_idx = content.find(HOOK_END_MARKER)

    if start_idx == -1 or end_idx == -1:
        logger.error("Hook markers not found despite is_hook_installed check",
                    path=str(hook_path))
        return False

    # Find the end of the end marker line
    end_line_end = content.find('\n', end_idx)
    if end_line_end == -1:
        end_line_end = len(content)
    else:
        end_line_end += 1  # Include the newline

    # Extract content before and after graphiti section
    before = content[:start_idx]
    after = content[end_line_end:]

    # Remove surrounding blank lines
    before = before.rstrip()
    after = after.lstrip()

    remaining_content = before + ("\n\n" + after if after else "")
    remaining_content = remaining_content.strip()

    if not remaining_content or remaining_content == "#!/bin/sh" or remaining_content == "#!/bin/bash":
        # Hook only contained graphiti content - remove entire file
        hook_path.unlink()
        logger.info(f"Removed entire {hook_type} hook (only graphiti content)",
                   path=str(hook_path))
    else:
        # Other content exists - write back without graphiti section
        hook_path.write_text(remaining_content + "\n")
        logger.info(f"Removed graphiti section from {hook_type} hook",
                   path=str(hook_path))

    return True


# Public API for pre-commit hook


def install_precommit_hook(repo_path: Path, force: bool = False) -> bool:
    """Install pre-commit hook for journal validation.

    Args:
        repo_path: Path to git repository
        force: If True, reinstall even if already installed

    Returns:
        True if hook was installed, False if already installed
    """
    return _install_hook("pre-commit", repo_path, force)


def is_precommit_hook_installed(repo_path: Path) -> bool:
    """Check if graphiti pre-commit hook is installed.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    return _is_hook_installed("pre-commit", repo_path)


def uninstall_precommit_hook(repo_path: Path) -> bool:
    """Remove graphiti section from pre-commit hook.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    return _uninstall_hook("pre-commit", repo_path)


# Public API for post-merge hook


def install_postmerge_hook(repo_path: Path, force: bool = False) -> bool:
    """Install post-merge hook for auto-heal.

    Args:
        repo_path: Path to git repository
        force: If True, reinstall even if already installed

    Returns:
        True if hook was installed, False if already installed
    """
    return _install_hook("post-merge", repo_path, force)


def is_postmerge_hook_installed(repo_path: Path) -> bool:
    """Check if graphiti post-merge hook is installed.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    return _is_hook_installed("post-merge", repo_path)


def uninstall_postmerge_hook(repo_path: Path) -> bool:
    """Remove graphiti section from post-merge hook.

    Args:
        repo_path: Path to git repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    return _uninstall_hook("post-merge", repo_path)


# Public API for post-checkout hook


def install_postcheckout_hook(git_dir: Path) -> bool:
    """Install post-checkout hook for background indexing on branch switches.

    The hook exits early on file checkouts ($3=0) and only triggers indexing
    on branch switches ($3=1) to avoid excessive indexing.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook was installed, False if already installed or on error
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    try:
        return _install_hook("post-checkout", repo_path)
    except Exception as e:
        logger.error("Failed to install post-checkout hook", git_dir=str(git_dir), error=str(e))
        return False


def is_postcheckout_hook_installed(git_dir: Path) -> bool:
    """Check if graphiti post-checkout hook is installed.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    return _is_hook_installed("post-checkout", repo_path)


def uninstall_postcheckout_hook(git_dir: Path) -> bool:
    """Remove graphiti section from post-checkout hook.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    return _uninstall_hook("post-checkout", repo_path)


# Public API for post-rewrite hook


def install_postrewrite_hook(git_dir: Path) -> bool:
    """Install post-rewrite hook for background indexing after rebase or amend.

    Triggered by 'git rebase' and 'git commit --amend' to re-index rewritten commits.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook was installed, False if already installed or on error
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    try:
        return _install_hook("post-rewrite", repo_path)
    except Exception as e:
        logger.error("Failed to install post-rewrite hook", git_dir=str(git_dir), error=str(e))
        return False


def is_postrewrite_hook_installed(git_dir: Path) -> bool:
    """Check if graphiti post-rewrite hook is installed.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook exists and contains GRAPHITI_HOOK_START marker
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    return _is_hook_installed("post-rewrite", repo_path)


def uninstall_postrewrite_hook(git_dir: Path) -> bool:
    """Remove graphiti section from post-rewrite hook.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if hook was uninstalled, False if not installed
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    return _uninstall_hook("post-rewrite", repo_path)


# Upgrade path for Phase 7 to Phase 7.1 migration


def _remove_hook_section(hook_path: Path) -> bool:
    """Remove all graphiti marker sections from a hook file.

    Handles the case where a hook contains an old graphiti section that needs
    to be replaced with an updated version. Removes content between all
    GRAPHITI_HOOK_START / GRAPHITI_HOOK_END marker pairs.

    Args:
        hook_path: Full path to the git hook file

    Returns:
        True if section was removed, False if no markers found or on error
    """
    if not hook_path.exists():
        return False

    try:
        content = hook_path.read_text()
    except Exception as e:
        logger.error("Failed to read hook file for removal", path=str(hook_path), error=str(e))
        return False

    if HOOK_START_MARKER not in content:
        return False

    # Remove all graphiti sections (handles edge case of multiple sections)
    result = content
    while HOOK_START_MARKER in result:
        start_idx = result.find(HOOK_START_MARKER)
        end_idx = result.find(HOOK_END_MARKER, start_idx)

        if end_idx == -1:
            # Malformed: start without end — remove from start to end of string
            result = result[:start_idx].rstrip()
            break

        # Find end of end-marker line
        end_line_end = result.find('\n', end_idx)
        if end_line_end == -1:
            end_line_end = len(result)
        else:
            end_line_end += 1

        before = result[:start_idx].rstrip()
        after = result[end_line_end:].lstrip()
        result = before + ("\n\n" + after if after else "")

    result = result.strip()

    if not result or result in ("#!/bin/sh", "#!/bin/bash"):
        # Hook only contained graphiti content — remove the file
        hook_path.unlink()
        logger.info("Removed entire hook file (only graphiti content)", path=str(hook_path))
    else:
        hook_path.write_text(result + "\n")
        logger.info("Removed graphiti section(s) from hook", path=str(hook_path))

    return True


def upgrade_postmerge_hook(git_dir: Path) -> bool:
    """Upgrade a Phase 7 post-merge hook to the Phase 7.1 indexer-based hook.

    Phase 7 installed a post-merge hook that called auto_heal() or replayed
    journal entries. Phase 7.1 replaces this with a lightweight background
    graphiti index trigger. This function detects old Phase 7 hooks and
    upgrades them in place.

    Args:
        git_dir: Path to the .git directory of the repository

    Returns:
        True if upgraded or already up-to-date, False on error
    """
    repo_path = git_dir.parent if git_dir.name == ".git" else git_dir
    hook_path = repo_path / ".git" / "hooks" / "post-merge"

    if not hook_path.exists():
        logger.info("No post-merge hook found, installing fresh", git_dir=str(git_dir))
        try:
            _install_hook("post-merge", repo_path)
            return True
        except Exception as e:
            logger.error("Failed to install post-merge hook", git_dir=str(git_dir), error=str(e))
            return False

    try:
        content = hook_path.read_text()
    except Exception as e:
        logger.error("Failed to read post-merge hook", path=str(hook_path), error=str(e))
        return False

    # Only attempt upgrade if graphiti installed this hook (has our marker)
    if HOOK_START_MARKER not in content:
        logger.info(
            "post-merge hook not installed by graphiti, skipping upgrade",
            path=str(hook_path)
        )
        return True

    # Detect Phase 7 autoheal / journal-based hook content
    old_indicators = ("autoheal", "auto_heal", "journal")
    is_old_phase7_hook = any(indicator in content for indicator in old_indicators)

    if not is_old_phase7_hook:
        logger.info(
            "post-merge hook already up-to-date (no Phase 7 journal references)",
            path=str(hook_path)
        )
        return True

    # Remove old hook section and reinstall with new template
    logger.info(
        "Upgrading post-merge hook from Phase 7 journal replay to Phase 7.1 git indexer",
        path=str(hook_path)
    )

    removed = _remove_hook_section(hook_path)
    if not removed and hook_path.exists():
        logger.warning(
            "Could not remove old hook section, aborting upgrade",
            path=str(hook_path)
        )
        return False

    try:
        _install_hook("post-merge", repo_path)
        logger.info(
            "Successfully upgraded post-merge hook to Phase 7.1 indexer",
            path=str(hook_path)
        )
        return True
    except Exception as e:
        logger.error(
            "Failed to install new post-merge hook after removal",
            git_dir=str(git_dir),
            error=str(e)
        )
        return False
