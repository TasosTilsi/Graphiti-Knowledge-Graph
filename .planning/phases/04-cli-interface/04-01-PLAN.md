---
phase: 04-cli-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/__init__.py
  - src/cli/output.py
  - src/cli/input.py
  - src/cli/utils.py
  - src/cli/commands/__init__.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Typer app instance exists and responds to --help"
    - "Both 'graphiti' and 'gk' entry points are registered in pyproject.toml"
    - "Rich console singleton provides consistent formatted output"
    - "stdin reading handles both piped and interactive modes safely"
    - "Typo suggestions fire for misspelled commands"
    - "Exit codes follow POSIX convention (0/1/2)"
  artifacts:
    - path: "src/cli/__init__.py"
      provides: "Typer app instance, cli_entry function, command registration scaffold"
      exports: ["app", "cli_entry"]
    - path: "src/cli/output.py"
      provides: "Rich console singleton, formatters for success/error/table/json/compact"
      exports: ["console", "print_success", "print_error", "print_warning", "print_table", "print_json", "print_compact"]
    - path: "src/cli/input.py"
      provides: "stdin reading with TTY detection, content resolution"
      exports: ["read_content"]
    - path: "src/cli/utils.py"
      provides: "Typo suggestions, confirmation prompts, scope resolution, exit codes"
      exports: ["suggest_command", "confirm_action", "resolve_scope", "EXIT_SUCCESS", "EXIT_ERROR", "EXIT_BAD_ARGS"]
    - path: "src/cli/commands/__init__.py"
      provides: "Empty init for commands package"
    - path: "pyproject.toml"
      provides: "Entry points for graphiti and gk CLI aliases, typer+rich dependencies"
      contains: "graphiti = \"src.cli:cli_entry\""
  key_links:
    - from: "src/cli/__init__.py"
      to: "src/cli/output.py"
      via: "imports console for error handling callback"
      pattern: "from.*output.*import"
    - from: "src/cli/utils.py"
      to: "src/storage/selector.py"
      via: "resolve_scope uses GraphSelector"
      pattern: "GraphSelector"
    - from: "pyproject.toml"
      to: "src/cli/__init__.py"
      via: "entry point reference"
      pattern: "src\\.cli:cli_entry"
---

<objective>
Create the CLI foundation: Typer app instance, Rich output module, input handling, utility functions, and pyproject.toml entry points. This is the shared infrastructure all commands depend on.

Purpose: Every CLI command needs the app instance to register with, the output module for consistent formatting, the input module for content reading, and utility functions for scope resolution, confirmations, and typo suggestions. Without this foundation, no commands can be built.

Output: Complete CLI skeleton with `graphiti --help` working, entry points registered, and all shared utilities ready for command implementations in subsequent plans.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-interface/04-CONTEXT.md
@.planning/phases/04-cli-interface/04-RESEARCH.md
@src/storage/selector.py
@src/models/context.py
@src/config/paths.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI app instance, output module, and entry points</name>
  <files>
    src/cli/__init__.py
    src/cli/output.py
    src/cli/commands/__init__.py
    pyproject.toml
  </files>
  <action>
Create `src/cli/__init__.py` with:
- Import typer, create `app = typer.Typer(name="graphiti", help="Knowledge graph operations for global preferences and project memory", no_args_is_help=True, invoke_without_command=True)`.
- Add a callback function that handles: (a) showing version with `--version` flag, (b) unknown command typo suggestions. Use Typer's callback decorator on app.
- Define `cli_entry()` function as the console_scripts entry point that calls `app()`.
- Command registration will be placeholder comments for now (commands added in plans 02-05). Register a dummy `version` command or just leave callback-only so `--help` works.

Create `src/cli/output.py` with Rich console singleton and formatters:
- `console = Console()` — singleton, auto-detects TTY.
- `err_console = Console(stderr=True)` — for error output.
- `print_success(message: str)` — green checkmark prefix: `[green]![/green] {message}`.
- `print_error(message: str, suggestion: str | None = None)` — red X prefix to stderr. If suggestion provided, print it below: `"Suggestion: {suggestion}"`.
- `print_warning(message: str)` — yellow warning prefix.
- `print_table(data: list[dict], title: str | None = None, columns: list[str] | None = None)` — Rich Table with auto-columns from dict keys or explicit column list. Styles: name=cyan, type=magenta, dates=green.
- `print_json(data: dict | list)` — calls `console.print_json(data=data)` for syntax-highlighted JSON.
- `print_compact(items: list[dict], name_key: str = "name", type_key: str = "type", snippet_key: str = "snippet")` — one-line-per-result: `{name} ({type}) - {snippet[:60]}...`.
- `format_output(data: dict | list, fmt: str | None = None)` — dispatch function: if fmt=="json" call print_json, else call appropriate Rich formatter. Returns None (prints directly).

Create `src/cli/commands/__init__.py` as empty file (package marker).

Update `pyproject.toml`:
- Add to `dependencies`: `"typer[all]>=0.15.0"` (includes rich, shellingham).
- Add `[project.scripts]` section with: `graphiti = "src.cli:cli_entry"` and `gk = "src.cli:cli_entry"`.
- Keep all existing dependencies intact.
  </action>
  <verify>
Run: `python -c "from src.cli import app; print(app.info.name)"` should print "graphiti".
Run: `python -c "from src.cli.output import console, print_success; print('OK')"` should print "OK".
Check pyproject.toml has both entry points: `grep -c "cli_entry" pyproject.toml` should return 2.
  </verify>
  <done>
Typer app instance importable, Rich console singleton importable, both entry points in pyproject.toml, commands/__init__.py exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create input handling and utility modules</name>
  <files>
    src/cli/input.py
    src/cli/utils.py
  </files>
  <action>
Create `src/cli/input.py` with stdin/content resolution:
- `read_content(positional: str | None = None) -> str` — Resolves content from positional arg or stdin.
  - If positional is not None: return positional (positional takes precedence, matching git behavior).
  - Elif `not sys.stdin.isatty()`: reconfigure stdin to UTF-8 with errors='replace', read and strip. Return content.
  - Else: raise `typer.BadParameter("No content provided. Pass as argument or pipe via stdin.\nUsage: graphiti add 'content' or echo 'content' | graphiti add")`.
- Handle empty stdin (stripped to empty string) same as no content — raise error.

Create `src/cli/utils.py` with shared utilities:
- Exit code constants: `EXIT_SUCCESS = 0`, `EXIT_ERROR = 1`, `EXIT_BAD_ARGS = 2`.
- `VALID_COMMANDS = ["add", "search", "delete", "list", "summarize", "compact", "config", "health", "show"]`.
- `suggest_command(invalid: str, cutoff: float = 0.6) -> str | None` — uses `difflib.get_close_matches(invalid, VALID_COMMANDS, n=1, cutoff=cutoff)`. Returns first match or None.
- `confirm_action(message: str, force: bool = False) -> bool` — if force returns True immediately. Otherwise calls `typer.confirm(message, abort=False)`. Returns the boolean result.
- `resolve_scope(global_flag: bool = False, project_flag: bool = False) -> tuple[GraphScope, Path | None]`:
  - If both flags set: raise `typer.BadParameter("Cannot use both --global and --project")`.
  - If global_flag: return `(GraphScope.GLOBAL, None)`.
  - If project_flag: find project root via `GraphSelector.find_project_root()`. If not found, raise error: `"Not in a git repository. Cannot use --project scope."`. Return `(GraphScope.PROJECT, project_root)`.
  - If neither (auto-detect): use `GraphSelector.determine_scope()`. Return result.
- `DEFAULT_LIMIT = 15` — default result limit per user decision (10-20 range, 15 chosen).

Import from existing modules: `from src.models import GraphScope` and `from src.storage import GraphSelector`.
  </action>
  <verify>
Run: `python -c "from src.cli.utils import suggest_command; print(suggest_command('serch'))"` should print "search".
Run: `python -c "from src.cli.utils import resolve_scope; scope, root = resolve_scope(global_flag=True); print(scope)"` should print "GraphScope.GLOBAL".
Run: `python -c "from src.cli.input import read_content; print(read_content('hello'))"` should print "hello".
Run: `python -c "from src.cli.utils import EXIT_SUCCESS, EXIT_ERROR, EXIT_BAD_ARGS; print(EXIT_SUCCESS, EXIT_ERROR, EXIT_BAD_ARGS)"` should print "0 1 2".
  </verify>
  <done>
read_content resolves positional args and stdin with proper TTY detection. suggest_command returns typo suggestions. resolve_scope auto-detects or respects --global/--project flags. Exit code constants defined. DEFAULT_LIMIT = 15.
  </done>
</task>

</tasks>

<verification>
- `python -c "from src.cli import app; app(['--help'], standalone_mode=False)"` shows help text
- `python -c "from src.cli.output import console; print(console.is_terminal)"` returns boolean
- `python -c "from src.cli.utils import suggest_command; assert suggest_command('delte') == 'delete'"` passes
- `grep 'graphiti.*cli_entry' pyproject.toml` shows both entry points
</verification>

<success_criteria>
1. `src/cli/__init__.py` creates functional Typer app with --help working
2. `src/cli/output.py` provides Rich console singleton with all formatter functions
3. `src/cli/input.py` handles positional arg and stdin content resolution
4. `src/cli/utils.py` provides scope resolution, typo suggestions, confirmations, exit codes
5. `pyproject.toml` registers both `graphiti` and `gk` entry points and adds typer dependency
6. All modules importable without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-01-SUMMARY.md`
</output>
