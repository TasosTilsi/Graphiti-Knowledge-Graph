---
phase: 04-cli-interface
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli/commands/add.py
  - src/cli/commands/search.py
  - src/cli/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can run 'graphiti add \"content\"' and see success confirmation"
    - "User can pipe content: 'echo content | graphiti add'"
    - "User can run 'graphiti search \"query\"' and see formatted results with title + snippet + metadata"
    - "Search defaults to semantic mode, --exact enables literal matching"
    - "Search filters --since, --before, --type, --tag work"
    - "--format json outputs parseable JSON for both commands"
    - "--quiet suppresses success messages for add"
    - "--compact shows one-line-per-result for search"
  artifacts:
    - path: "src/cli/commands/add.py"
      provides: "Add command with positional+stdin input, scope detection, tagging, source provenance"
      exports: ["add_command"]
    - path: "src/cli/commands/search.py"
      provides: "Search command with semantic/exact modes, filters, result formatting"
      exports: ["search_command"]
  key_links:
    - from: "src/cli/commands/add.py"
      to: "src/cli/input.py"
      via: "read_content() for input resolution"
      pattern: "read_content"
    - from: "src/cli/commands/add.py"
      to: "src/cli/output.py"
      via: "print_success, console.status for spinner"
      pattern: "print_success|console\\.status"
    - from: "src/cli/commands/search.py"
      to: "src/cli/output.py"
      via: "print_table, print_compact, print_json for results"
      pattern: "print_table|print_compact|print_json"
    - from: "src/cli/__init__.py"
      to: "src/cli/commands/add.py"
      via: "app.command registration"
      pattern: "app\\.command"
---

<objective>
Implement the `add` and `search` CLI commands - the two most fundamental operations for a knowledge graph. Add writes content, search retrieves it. Both commands integrate with the storage and LLM layers.

Purpose: These are the primary read/write operations users will use most frequently. Add must handle both positional arguments and stdin for flexible input. Search must support semantic (default) and exact modes with rich result formatting.

Output: Working `graphiti add` and `graphiti search` commands registered with the Typer app.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-cli-interface/04-CONTEXT.md
@.planning/phases/04-cli-interface/04-RESEARCH.md
@.planning/phases/04-cli-interface/04-01-SUMMARY.md
@src/cli/__init__.py
@src/cli/output.py
@src/cli/input.py
@src/cli/utils.py
@src/storage/graph_manager.py
@src/storage/selector.py
@src/llm/__init__.py
@src/models/context.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement add command</name>
  <files>src/cli/commands/add.py</files>
  <action>
Create `src/cli/commands/add.py` implementing `graphiti add`:

Function signature using Typer annotations:
```
def add_command(
    content: Annotated[Optional[str], typer.Argument(help="Content to add to knowledge graph")] = None,
    tag: Annotated[Optional[list[str]], typer.Option("--tag", "-t", help="Tags for categorization (can repeat)")] = None,
    source: Annotated[Optional[str], typer.Option("--source", "-s", help="Source provenance (auto-detected if omitted)")] = None,
    global_scope: Annotated[bool, typer.Option("--global", "-g", help="Use global scope")] = False,
    project_scope: Annotated[bool, typer.Option("--project", "-p", help="Use project scope")] = False,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
    quiet: Annotated[bool, typer.Option("--quiet", "-q", help="Suppress success messages")] = False,
)
```

Implementation:
1. Resolve content using `read_content(content)` from `src.cli.input`.
2. Resolve scope using `resolve_scope(global_scope, project_scope)` from `src.cli.utils`.
3. Auto-detect source if not provided: check if in git repo, default to "manual" if not.
4. Use `console.status("Adding to knowledge graph...")` spinner during operation.
5. Call storage layer to add entity (for now, create a stub `_add_entity()` function that prepares the data dict but returns a mock result with name, type, scope, created_at fields — the actual graph write will be wired when graph operations are fully implemented. The stub should log what it would do and return realistic data so the CLI flow is testable end-to-end).
6. On success: if format=="json", print_json the result dict. Elif not quiet, print_success with entity name.
7. Wrap in try/except: catch `typer.BadParameter` (re-raise), catch `Exception` as runtime error with EXIT_ERROR.
8. Handle `--tag`: if provided, include in entity data. If not provided, note that LLM auto-categorization will be added in future (comment in code).

IMPORTANT: The add command must handle auto-init on first use. If the resolved scope is PROJECT and the .graphiti/ directory doesn't exist, create it automatically. Use `from src.config.paths import get_project_db_path` to determine the path.
  </action>
  <verify>
Run: `python -c "from src.cli.commands.add import add_command; print(add_command.__name__)"` should print "add_command".
Verify the function has proper Typer annotations by checking it has `__wrapped__` or inspecting parameter annotations.
  </verify>
  <done>
add_command accepts positional content or stdin, resolves scope, shows spinner, prints success/JSON output, handles --quiet, auto-inits .graphiti/ directory for project scope.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search command and register both with app</name>
  <files>
    src/cli/commands/search.py
    src/cli/__init__.py
  </files>
  <action>
Create `src/cli/commands/search.py` implementing `graphiti search`:

Function signature:
```
def search_command(
    query: Annotated[str, typer.Argument(help="Search query")],
    exact: Annotated[bool, typer.Option("--exact", "-e", help="Literal string matching instead of semantic")] = False,
    global_scope: Annotated[bool, typer.Option("--global", "-g", help="Search global scope only")] = False,
    project_scope: Annotated[bool, typer.Option("--project", "-p", help="Search project scope only")] = False,
    since: Annotated[Optional[str], typer.Option("--since", help="Filter results after date/duration (e.g., '7d', '2024-01-01')")] = None,
    before: Annotated[Optional[str], typer.Option("--before", help="Filter results before date")] = None,
    type_filter: Annotated[Optional[str], typer.Option("--type", help="Filter by type: entity, relationship")] = None,
    tag: Annotated[Optional[list[str]], typer.Option("--tag", "-t", help="Filter by tag")] = None,
    limit: Annotated[int, typer.Option("--limit", "-l", help="Max results to return")] = DEFAULT_LIMIT,
    all_results: Annotated[bool, typer.Option("--all", help="Return all results (no limit)")] = False,
    compact: Annotated[bool, typer.Option("--compact", "-c", help="One-line-per-result view")] = False,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
)
```

Implementation:
1. Resolve scope using `resolve_scope(global_scope, project_scope)`.
2. Determine effective limit: if all_results, set limit=None; else use limit param.
3. Use `console.status("Searching knowledge graph...")` spinner.
4. Call search (stub `_search_entities()` that returns mock results list — each result dict has: name, type, snippet, score, created_at, scope, tags. Return 3-5 mock results for now so formatting is testable).
5. If no results: print_warning("No results found for '{query}'") and exit 0.
6. Format output based on flags:
   - format=="json": print_json(results list).
   - compact: print_compact(results).
   - default: print_table with columns [Name, Type, Snippet, Score, Created].
7. Print result count below: "{N} results" or "{N} of {total} results (use --all for complete list)".
8. Wrap in try/except with proper exit codes.

**Search result formatting per CONTEXT.md:** title + snippet (highlighted match) + metadata (type, created date, scope).

Update `src/cli/__init__.py`:
- Import add_command from src.cli.commands.add and search_command from src.cli.commands.search.
- Register with app: `app.command(name="add", help="Add content to the knowledge graph")(add_command)` and `app.command(name="search", help="Search the knowledge graph")(search_command)`.
- In the app callback, add typo suggestion logic: if an unknown command is provided, use `suggest_command()` and print "Did you mean '{suggestion}'?" before showing help.
  </action>
  <verify>
Run: `python -c "from src.cli import app; from typer.testing import CliRunner; r = CliRunner(); result = r.invoke(app, ['--help']); print('add' in result.output and 'search' in result.output)"` should print True.
Run: `python -c "from src.cli.commands.search import search_command; print(search_command.__name__)"` should print "search_command".
  </verify>
  <done>
search_command supports semantic (default) and --exact modes, --since/--before/--type/--tag filters, --limit/--all result control, --compact one-liner view, --format json output. Both add and search commands registered in app and visible in --help.
  </done>
</task>

</tasks>

<verification>
- `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['add', 'test content']); print(result.exit_code, result.output)"` shows exit_code=0 with success message
- `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['search', 'test query']); print(result.exit_code, result.output)"` shows exit_code=0 with results
- `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['add', 'test', '--format', 'json']); print(result.output)"` shows JSON output
</verification>

<success_criteria>
1. `graphiti add "content"` adds content and shows success message
2. `echo "content" | graphiti add` reads from stdin
3. `graphiti add --quiet` suppresses output
4. `graphiti add --format json` outputs JSON
5. `graphiti search "query"` shows formatted table of results
6. `graphiti search --exact "literal"` uses literal matching mode
7. `graphiti search --compact` shows one-line-per-result
8. `graphiti search --format json` outputs JSON array
9. Scope auto-detection works, --global/--project flags override
10. Both commands visible in `graphiti --help`
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-02-SUMMARY.md`
</output>
