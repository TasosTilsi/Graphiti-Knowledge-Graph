---
phase: 04-cli-interface
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/service.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "graphiti list shows entities that were previously added via graphiti add"
    - "graphiti show <name> displays entity details with its relationships"
    - "graphiti delete <name> removes the entity from the graph"
    - "graphiti compact displays accurate entity and relationship counts"
  artifacts:
    - path: "src/graph/service.py"
      provides: "Working implementations of list_entities, get_entity, delete_entities, get_stats"
      contains: "await driver.execute_query"
  key_links:
    - from: "GraphService.list_entities()"
      to: "EntityNode.get_by_group_ids()"
      via: "graphiti_core API call"
      pattern: "EntityNode\\.get_by_group_ids"
    - from: "GraphService.get_entity()"
      to: "driver.execute_query"
      via: "Kuzu Cypher query on Entity table"
      pattern: "MATCH.*Entity.*name"
    - from: "GraphService.delete_entities()"
      to: "Node.delete_by_uuids()"
      via: "graphiti_core API for Kuzu-safe deletion"
      pattern: "Node\\.delete_by_uuids|EntityNode.*delete"
    - from: "GraphService.get_stats()"
      to: "driver.execute_query"
      via: "COUNT queries on Entity and RelatesToNode_ tables"
      pattern: "COUNT"
---

<objective>
Implement the 4 query-based GraphService methods (list_entities, get_entity, delete_entities, get_stats) that currently return placeholders.

Purpose: These methods power the list, show, delete, and compact CLI commands. Without them, users cannot see, inspect, delete, or get statistics about entities in their knowledge graph.

Output: Working implementations in src/graph/service.py that execute real Kuzu queries via graphiti_core APIs and direct Cypher queries.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-interface/04-07-SUMMARY.md

Source files:
@src/graph/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement list_entities and get_entity methods</name>
  <files>src/graph/service.py</files>
  <action>
Replace the placeholder implementations of list_entities() and get_entity() in GraphService with real graph operations.

**list_entities() (currently lines 357-362):**

Use graphiti_core's built-in EntityNode.get_by_group_ids() method which already handles Kuzu-specific query formatting. This is the same pattern used internally by graphiti_core and avoids writing raw Cypher.

Implementation:
1. Add import at top: `from graphiti_core.nodes import EntityNode` (EpisodicNode and EpisodeType are already imported from graphiti_core)
2. Get the graphiti instance (to access the driver): `graphiti = self._get_graphiti(scope, project_root)`
3. Get group_id: `group_id = self._get_group_id(scope, project_root)`
4. Call: `entities = await EntityNode.get_by_group_ids(graphiti.driver, group_ids=[group_id], limit=limit)`
5. For each entity, count relationships with a separate query on the driver:
   ```python
   MATCH (n:Entity {uuid: $uuid})-[:RELATES_TO]->(e:RelatesToNode_)
   RETURN count(e) AS rel_count
   ```
6. Convert EntityNode objects to dicts matching the existing return format:
   ```python
   {
       "name": entity.name,
       "type": "entity",
       "created_at": entity.created_at.isoformat(),
       "tags": entity.labels,
       "scope": scope.value,
       "relationship_count": rel_count,
   }
   ```
7. Return the list of dicts. If EntityNode.get_by_group_ids returns empty, return [].
8. Wrap in try/except: catch all exceptions, log error, and raise.
9. Remove the TODO comment and logger.warning("list_entities not yet implemented...") line.

**get_entity() (currently lines 390-394):**

Search for entities by name using a case-insensitive CONTAINS query on the Entity table, then fetch relationships for matched entities.

Implementation:
1. Get driver via graphiti instance: `graphiti = self._get_graphiti(scope, project_root)` and `driver = graphiti.driver`
2. Get group_id: `group_id = self._get_group_id(scope, project_root)`
3. Query entities matching the name (case-insensitive partial match):
   ```python
   records, _, _ = await driver.execute_query(
       """
       MATCH (n:Entity)
       WHERE n.group_id = $group_id AND lower(n.name) CONTAINS lower($name)
       RETURN
           n.uuid AS uuid,
           n.name AS name,
           n.group_id AS group_id,
           n.labels AS labels,
           n.created_at AS created_at,
           n.summary AS summary,
           n.attributes AS attributes
       """,
       group_id=group_id,
       name=name,
   )
   ```
4. If no records, return None.
5. For each matched entity, fetch its relationships:
   ```python
   edge_records, _, _ = await driver.execute_query(
       """
       MATCH (n:Entity {uuid: $uuid})-[:RELATES_TO]->(e:RelatesToNode_)-[:RELATES_TO]->(m:Entity)
       RETURN e.name AS name, e.fact AS fact, m.name AS target_name, e.created_at AS created_at
       """,
       uuid=record["uuid"],
   )
   ```
   Also fetch incoming relationships:
   ```python
   incoming_records, _, _ = await driver.execute_query(
       """
       MATCH (m:Entity)-[:RELATES_TO]->(e:RelatesToNode_)-[:RELATES_TO]->(n:Entity {uuid: $uuid})
       RETURN e.name AS name, e.fact AS fact, m.name AS source_name, e.created_at AS created_at
       """,
       uuid=record["uuid"],
   )
   ```
6. Build entity dict:
   ```python
   import json as _json  # at module level if not already imported
   attributes = _json.loads(record["attributes"]) if record["attributes"] else {}
   entity_dict = {
       "name": record["name"],
       "type": "entity",
       "created_at": record["created_at"].isoformat() if hasattr(record["created_at"], "isoformat") else str(record["created_at"]),
       "tags": record["labels"] or [],
       "scope": scope.value,
       "summary": record["summary"] or "",
       "attributes": attributes,
       "relationships": [
           {"name": er["name"], "fact": er["fact"], "target": er["target_name"],
            "created_at": str(er["created_at"])}
           for er in edge_records
       ] + [
           {"name": er["name"], "fact": er["fact"], "source": er["source_name"],
            "created_at": str(er["created_at"])}
           for er in incoming_records
       ],
   }
   ```
7. If exactly one match, return the single dict. If multiple matches, return list of dicts (for disambiguation). If zero matches, return None.
8. Remove the TODO comment and logger.warning line.

**Important notes:**
- Do NOT import json again if it is not already imported at module level. Check the imports first. If json is not imported, add `import json` at top of file.
- The Kuzu driver's execute_query returns `(records, None, None)` where records is a list of dicts.
- Use `from graphiti_core.nodes import EntityNode` -- EpisodeType is already imported from graphiti_core.nodes but EntityNode is not. The existing import is `from graphiti_core.nodes import EpisodeType`. Update this to `from graphiti_core.nodes import EntityNode, EpisodeType`.
- The graphiti instance has a `driver` attribute that gives direct access to the KuzuDriver.
- For created_at from Kuzu: it returns as a Python datetime or possibly as a string. Use `str()` for safety.
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "from src.graph.service import GraphService; print('Import OK')"` should succeed.

Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
source = inspect.getsource(GraphService.list_entities)
assert 'TODO' not in source, 'list_entities still has TODO'
assert 'not yet implemented' not in source, 'list_entities still has placeholder warning'
assert 'EntityNode' in source or 'execute_query' in source, 'list_entities has no query logic'
source2 = inspect.getsource(GraphService.get_entity)
assert 'TODO' not in source2, 'get_entity still has TODO'
assert 'not yet implemented' not in source2, 'get_entity still has placeholder warning'
assert 'execute_query' in source2, 'get_entity has no query logic'
print('All checks passed')
"` should print "All checks passed".
  </verify>
  <done>list_entities() queries real Entity nodes from Kuzu via EntityNode.get_by_group_ids() and returns dicts with name, type, created_at, tags, scope, relationship_count. get_entity() finds entities by name with case-insensitive CONTAINS matching, fetches outgoing and incoming relationships, and returns single dict (one match), list of dicts (multiple matches), or None (no matches).</done>
</task>

<task type="auto">
  <name>Task 2: Implement delete_entities and get_stats methods</name>
  <files>src/graph/service.py</files>
  <action>
Replace the placeholder implementations of delete_entities() and get_stats() in GraphService with real graph operations.

**delete_entities() (currently lines 414-416):**

Delete entities by name. First find entities matching the given names, then use graphiti_core's Node.delete_by_uuids() which properly handles Kuzu's edge-as-node pattern (deletes RelatesToNode_ nodes first, then Entity nodes).

Implementation:
1. Add import at top if not already present: `from graphiti_core.nodes import Node` -- Note: Node may need to be imported. Check if it's available. The Node base class has delete_by_uuids(). Update the import to include Node: `from graphiti_core.nodes import EntityNode, EpisodeType, Node`
2. Get driver via graphiti: `graphiti = self._get_graphiti(scope, project_root)` and `driver = graphiti.driver`
3. Get group_id: `group_id = self._get_group_id(scope, project_root)`
4. Find UUIDs of entities to delete by matching names:
   ```python
   uuids_to_delete = []
   for name in names:
       records, _, _ = await driver.execute_query(
           """
           MATCH (n:Entity)
           WHERE n.group_id = $group_id AND lower(n.name) = lower($name)
           RETURN n.uuid AS uuid
           """,
           group_id=group_id,
           name=name,
       )
       uuids_to_delete.extend([r["uuid"] for r in records])
   ```
5. If no UUIDs found, return 0.
6. Delete using graphiti_core's API which handles Kuzu-specific deletion pattern:
   ```python
   await Node.delete_by_uuids(driver, uuids_to_delete)
   ```
7. Return `len(uuids_to_delete)` as the count of deleted entities.
8. Wrap in try/except, log errors, raise.
9. Remove the TODO comment and logger.warning line.

**get_stats() (currently lines 485-491):**

Get graph statistics using COUNT queries on Kuzu tables.

Implementation:
1. Get driver via graphiti: `graphiti = self._get_graphiti(scope, project_root)` and `driver = graphiti.driver`
2. Get group_id: `group_id = self._get_group_id(scope, project_root)`
3. Count entities:
   ```python
   entity_records, _, _ = await driver.execute_query(
       """
       MATCH (n:Entity)
       WHERE n.group_id = $group_id
       RETURN count(n) AS cnt
       """,
       group_id=group_id,
   )
   entity_count = entity_records[0]["cnt"] if entity_records else 0
   ```
4. Count relationships (RelatesToNode_ nodes represent edges in Kuzu):
   ```python
   rel_records, _, _ = await driver.execute_query(
       """
       MATCH (n:Entity)-[:RELATES_TO]->(e:RelatesToNode_)-[:RELATES_TO]->(m:Entity)
       WHERE e.group_id = $group_id
       RETURN count(e) AS cnt
       """,
       group_id=group_id,
   )
   relationship_count = rel_records[0]["cnt"] if rel_records else 0
   ```
5. Count episodes:
   ```python
   ep_records, _, _ = await driver.execute_query(
       """
       MATCH (e:Episodic)
       WHERE e.group_id = $group_id
       RETURN count(e) AS cnt
       """,
       group_id=group_id,
   )
   episode_count = ep_records[0]["cnt"] if ep_records else 0
   ```
6. For database size, get the Kuzu database path and check file size on disk:
   ```python
   import os
   db_path = str(graphiti.driver.db.database_path) if hasattr(graphiti.driver, 'db') and hasattr(graphiti.driver.db, 'database_path') else None
   size_bytes = 0
   if db_path:
       try:
           for dirpath, dirnames, filenames in os.walk(db_path):
               for f in filenames:
                   fp = os.path.join(dirpath, f)
                   size_bytes += os.path.getsize(fp)
       except OSError:
           size_bytes = 0
   ```
   Note: If accessing db.database_path fails, fall back to computing from the path configuration:
   ```python
   from src.config.paths import GLOBAL_DB_PATH, get_project_db_path
   if db_path is None:
       if scope == GraphScope.GLOBAL:
           db_path = str(GLOBAL_DB_PATH)
       elif project_root:
           db_path = str(get_project_db_path(project_root))
   ```
7. Return the stats dict:
   ```python
   return {
       "entity_count": entity_count,
       "relationship_count": relationship_count,
       "episode_count": episode_count,
       "duplicate_count": 0,  # Duplicate detection is handled by compact()
       "size_bytes": size_bytes,
   }
   ```
8. Wrap in try/except, log errors, return zeros dict on failure rather than raising (stats should be best-effort).
9. Remove the TODO comment and logger.warning line.
10. Add `import os` at top of file if not already there.

**Import consolidation:** After both tasks, the imports at the top of service.py should include:
- `import json` (if not already present, for get_entity attributes parsing)
- `import os` (for get_stats file size)
- `from graphiti_core.nodes import EntityNode, EpisodeType, Node` (extending existing import)

Do NOT add `from graphiti_core.nodes import EpisodicNode` unless needed.
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
source = inspect.getsource(GraphService.delete_entities)
assert 'TODO' not in source, 'delete_entities still has TODO'
assert 'not yet implemented' not in source, 'delete_entities still has placeholder warning'
assert 'delete' in source.lower(), 'delete_entities has no delete logic'
source2 = inspect.getsource(GraphService.get_stats)
assert 'TODO' not in source2, 'get_stats still has TODO'
assert 'not yet implemented' not in source2, 'get_stats still has placeholder warning'
assert 'count' in source2.lower() or 'COUNT' in source2, 'get_stats has no count logic'
print('All checks passed')
"` should print "All checks passed".

Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
# Verify NO placeholder methods remain for these 4 methods
for method_name in ['list_entities', 'get_entity', 'delete_entities', 'get_stats']:
    source = inspect.getsource(getattr(GraphService, method_name))
    assert 'not yet implemented' not in source, f'{method_name} still has placeholder'
    assert 'TODO' not in source, f'{method_name} still has TODO'
print('No placeholders remain in query methods')
"` should print "No placeholders remain in query methods".
  </verify>
  <done>delete_entities() finds entities by exact name match (case-insensitive), collects UUIDs, and uses Node.delete_by_uuids() for Kuzu-safe deletion including RelatesToNode_ cleanup. get_stats() returns entity_count, relationship_count, episode_count, duplicate_count (0 until compact), and size_bytes from COUNT queries and filesystem inspection.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `from src.graph.service import GraphService` imports without error
2. No TODO comments remain in the 4 implemented methods
3. No "not yet implemented" warnings remain in the 4 methods
4. All methods contain actual Kuzu query logic (EntityNode.get_by_group_ids, execute_query, Node.delete_by_uuids, COUNT)
5. Import statements at top of file are clean (no duplicates, no unused imports)
</verification>

<success_criteria>
- list_entities() uses EntityNode.get_by_group_ids() to fetch real entities from Kuzu and returns them as list of dicts
- get_entity() queries Entity table by name with case-insensitive CONTAINS, fetches relationships via RelatesToNode_ join, returns dict/list/None
- delete_entities() finds entities by name, uses Node.delete_by_uuids() for Kuzu-safe deletion, returns count
- get_stats() runs COUNT queries on Entity, RelatesToNode_, and Episodic tables filtered by group_id, plus filesystem size
- Zero placeholder/TODO comments remain in these 4 methods
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-10-SUMMARY.md`
</output>
