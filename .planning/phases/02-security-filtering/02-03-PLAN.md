---
phase: 02-security-filtering
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/security/detector.py
  - src/security/patterns.py
  - src/security/allowlist.py
autonomous: true

must_haves:
  truths:
    - "Known secret formats (AWS keys, GitHub tokens, JWTs) are detected"
    - "High-entropy strings are flagged even without pattern match"
    - "Per-project allowlist can override false positives"
    - "Allowlist entries require hash verification (not plain text)"
  artifacts:
    - path: "src/security/detector.py"
      provides: "SecretDetector using detect-secrets with aggressive thresholds"
      exports: ["SecretDetector", "detect_secrets_in_content"]
    - path: "src/security/patterns.py"
      provides: "Pattern definitions and type mapping"
      contains: "DETECTION_TYPE_MAP"
    - path: "src/security/allowlist.py"
      provides: "Per-project allowlist management"
      exports: ["Allowlist", "is_allowlisted"]
  key_links:
    - from: "src/security/detector.py"
      to: "detect_secrets"
      via: "SecretsCollection.scan_string"
      pattern: "from detect_secrets"
    - from: "src/security/detector.py"
      to: "src/config/security.py"
      via: "imports DETECT_SECRETS_PLUGINS"
      pattern: "from src.config.security import"
    - from: "src/security/allowlist.py"
      to: "hashlib"
      via: "SHA256 hashing for allowlist keys"
      pattern: "hashlib.sha256"
---

<objective>
Implement secret detection engine and per-project allowlist management.

Purpose: The detector is the core of security filtering - it identifies secrets using detect-secrets library with aggressive thresholds. The allowlist provides an escape hatch for false positives without compromising security.

Output: SecretDetector class with pattern + entropy detection, Allowlist class with hash-based verification.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-security-filtering/02-CONTEXT.md
@.planning/phases/02-security-filtering/02-RESEARCH.md
@src/models/security.py
@src/config/security.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pattern definitions and secret detector</name>
  <files>src/security/patterns.py, src/security/detector.py</files>
  <action>
1. Create src/security/patterns.py with detection type mappings:

```python
"""Pattern definitions and detection type mapping for secret detection.

Maps detect-secrets plugin types to our DetectionType enum for
consistent categorization across the security filtering pipeline.
"""
from src.models.security import DetectionType

# Map detect-secrets plugin names to our DetectionType enum
DETECTION_TYPE_MAP: dict[str, DetectionType] = {
    # AWS detectors
    "AWSKeyDetector": DetectionType.AWS_KEY,

    # GitHub
    "GitHubTokenDetector": DetectionType.GITHUB_TOKEN,

    # JWT
    "JwtTokenDetector": DetectionType.JWT,

    # Private keys
    "PrivateKeyDetector": DetectionType.PRIVATE_KEY,

    # Entropy-based
    "Base64HighEntropyString": DetectionType.HIGH_ENTROPY_BASE64,
    "HexHighEntropyString": DetectionType.HIGH_ENTROPY_HEX,

    # Generic patterns (KeywordDetector, BasicAuth)
    "KeywordDetector": DetectionType.GENERIC_API_KEY,
    "BasicAuthDetector": DetectionType.GENERIC_API_KEY,
}

# Confidence mapping based on detection method
CONFIDENCE_MAP: dict[str, str] = {
    # Pattern-based detectors are high confidence
    "AWSKeyDetector": "high",
    "GitHubTokenDetector": "high",
    "JwtTokenDetector": "high",
    "PrivateKeyDetector": "high",

    # Entropy-based are medium (more false positives)
    "Base64HighEntropyString": "medium",
    "HexHighEntropyString": "medium",

    # Keyword-based are medium
    "KeywordDetector": "medium",
    "BasicAuthDetector": "medium",
}


def get_detection_type(plugin_name: str) -> DetectionType:
    """Get DetectionType for a detect-secrets plugin.

    Args:
        plugin_name: Name of detect-secrets plugin

    Returns:
        Corresponding DetectionType, defaults to GENERIC_API_KEY
    """
    return DETECTION_TYPE_MAP.get(plugin_name, DetectionType.GENERIC_API_KEY)


def get_confidence(plugin_name: str) -> str:
    """Get confidence level for a detect-secrets plugin.

    Args:
        plugin_name: Name of detect-secrets plugin

    Returns:
        Confidence level (high, medium, low)
    """
    return CONFIDENCE_MAP.get(plugin_name, "medium")
```

2. Create src/security/detector.py with SecretDetector class:

```python
"""Secret detection using detect-secrets with aggressive thresholds.

Combines pattern-based detection (AWS keys, GitHub tokens, etc.)
with entropy-based detection (catches random-looking strings).
User decision: Very aggressive - prefer false positives over leaking secrets.
"""
import re
import tempfile
from pathlib import Path
from typing import Optional

from detect_secrets import SecretsCollection
from detect_secrets.settings import transient_settings

from src.config.security import DETECT_SECRETS_PLUGINS
from src.models.security import SecretFinding, DetectionType
from src.security.patterns import get_detection_type, get_confidence


class SecretDetector:
    """Detects secrets in content using detect-secrets library."""

    def __init__(self, plugins_config: dict | None = None):
        """Initialize detector with plugin configuration.

        Args:
            plugins_config: Custom detect-secrets plugins config.
                          Uses aggressive defaults if None.
        """
        self._plugins = plugins_config or DETECT_SECRETS_PLUGINS

    def detect(
        self,
        content: str,
        file_path: str | None = None,
    ) -> list[SecretFinding]:
        """Detect secrets in content.

        Args:
            content: Text content to scan
            file_path: Optional source file path for reporting

        Returns:
            List of SecretFinding objects for detected secrets
        """
        findings: list[SecretFinding] = []

        # detect-secrets requires file-based scanning, use temp file
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".txt",
            delete=False
        ) as tmp:
            tmp.write(content)
            tmp_path = tmp.name

        try:
            # Configure detect-secrets with our aggressive settings
            with transient_settings({"plugins_used": self._plugins}):
                secrets = SecretsCollection()
                secrets.scan_file(tmp_path)

                # Convert to our SecretFinding format
                for detected_file, secret_list in secrets.files.items():
                    for secret in secret_list:
                        # Get the actual secret value from content
                        lines = content.split('\n')
                        if 0 < secret.line_number <= len(lines):
                            line = lines[secret.line_number - 1]
                            matched_text = self._extract_secret_from_line(
                                line, secret.type
                            )
                        else:
                            matched_text = "<detected_but_not_extracted>"

                        finding = SecretFinding(
                            detection_type=get_detection_type(secret.type),
                            matched_text=matched_text,
                            line_number=secret.line_number,
                            confidence=get_confidence(secret.type),
                            file_path=file_path,
                        )
                        findings.append(finding)
        finally:
            # Clean up temp file
            Path(tmp_path).unlink(missing_ok=True)

        return findings

    def _extract_secret_from_line(
        self,
        line: str,
        plugin_type: str
    ) -> str:
        """Extract the actual secret value from a line.

        detect-secrets gives us line numbers but not the exact match.
        We use patterns to extract the actual secret value.

        Args:
            line: The line containing the secret
            plugin_type: Type of detector that found it

        Returns:
            The extracted secret string
        """
        # Common extraction patterns
        patterns = {
            "AWSKeyDetector": r"(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}",
            "GitHubTokenDetector": r"(ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36}|ghu_[a-zA-Z0-9]{36}|ghs_[a-zA-Z0-9]{36}|ghr_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9_]{22,})",
            "JwtTokenDetector": r"eyJ[a-zA-Z0-9\-_]+\.eyJ[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+",
            "PrivateKeyDetector": r"-----BEGIN[^-]+-----",
            "Base64HighEntropyString": r"[A-Za-z0-9+/]{20,}={0,2}",
            "HexHighEntropyString": r"[a-fA-F0-9]{20,}",
        }

        pattern = patterns.get(plugin_type)
        if pattern:
            match = re.search(pattern, line)
            if match:
                return match.group(0)

        # Fallback: return trimmed line (without obvious prefixes)
        # Remove common prefixes like "API_KEY = "
        cleaned = re.sub(r"^[A-Za-z_]+\s*[=:]\s*['\"]?", "", line.strip())
        cleaned = re.sub(r"['\"]?\s*$", "", cleaned)
        return cleaned if cleaned else line.strip()


def detect_secrets_in_content(
    content: str,
    file_path: str | None = None,
) -> list[SecretFinding]:
    """Convenience function to detect secrets in content.

    Args:
        content: Text to scan
        file_path: Optional source path

    Returns:
        List of detected secrets
    """
    detector = SecretDetector()
    return detector.detect(content, file_path)
```

Key implementation notes:
- Uses detect_secrets with transient_settings for thread safety
- Aggressive entropy thresholds from config (3.5 base64, 2.5 hex)
- Maps detect-secrets types to our DetectionType enum
- Extracts actual secret text for masking (not just line numbers)
  </action>
  <verify>
python -c "
from src.security.detector import SecretDetector, detect_secrets_in_content

detector = SecretDetector()

# Test AWS key detection
test_content = '''
AWS_ACCESS_KEY_ID = \"AKIAIOSFODNN7EXAMPLE\"
normal_variable = \"hello world\"
'''

findings = detector.detect(test_content)
print(f'Found {len(findings)} potential secrets')

# Test JWT detection
jwt_content = 'token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U'
jwt_findings = detector.detect(jwt_content)
print(f'JWT test found {len(jwt_findings)} secrets')

# At least one finding expected (may vary by detect-secrets version)
print('Secret detection OK')
"
  </verify>
  <done>
SecretDetector works with detect-secrets library. AWS keys, JWTs, and high-entropy strings are detected. Detection results include type, line number, and matched text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create allowlist management</name>
  <files>src/security/allowlist.py, src/security/__init__.py</files>
  <action>
Create src/security/allowlist.py:

```python
"""Per-project allowlist for false positive management.

Stores SHA256 hashes of allowlisted content (never plain text)
with required comments explaining why each entry is safe.
User decision: Optional, disabled by default, maximum security.
"""
import hashlib
import json
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional


@dataclass
class AllowlistEntry:
    """Entry in the allowlist with audit metadata."""
    hash: str  # SHA256 hash of the allowlisted text
    comment: str  # Required explanation of why this is safe
    added_date: str  # ISO format timestamp
    added_by: str  # Who added this (e.g., git user)


class Allowlist:
    """Per-project allowlist management.

    Stores allowlist in .graphiti/allowlist.json with:
    - SHA256 hashes (never plain text secrets)
    - Required comments for each entry
    - Audit metadata (date, who added)
    """

    def __init__(self, project_root: Path | None = None):
        """Initialize allowlist for a project.

        Args:
            project_root: Project root directory. Uses cwd if None.
        """
        self._root = project_root or Path.cwd()
        self._path = self._root / ".graphiti" / "allowlist.json"
        self._entries: dict[str, AllowlistEntry] = {}
        self._load()

    def _load(self) -> None:
        """Load allowlist from disk if exists."""
        if not self._path.exists():
            return

        try:
            with open(self._path) as f:
                data = json.load(f)

            # Parse entries
            for hash_key in data.get("allowed_patterns", []):
                self._entries[hash_key] = AllowlistEntry(
                    hash=hash_key,
                    comment=data.get("comments", {}).get(hash_key, ""),
                    added_date=data.get("metadata", {}).get(hash_key, {}).get("added_date", ""),
                    added_by=data.get("metadata", {}).get(hash_key, {}).get("added_by", ""),
                )
        except (json.JSONDecodeError, KeyError):
            # Corrupted file, start fresh
            self._entries = {}

    def _save(self) -> None:
        """Save allowlist to disk."""
        self._path.parent.mkdir(parents=True, exist_ok=True)

        data = {
            "allowed_patterns": list(self._entries.keys()),
            "comments": {h: e.comment for h, e in self._entries.items()},
            "metadata": {
                h: {"added_date": e.added_date, "added_by": e.added_by}
                for h, e in self._entries.items()
            },
        }

        with open(self._path, "w") as f:
            json.dump(data, f, indent=2)

    @staticmethod
    def compute_hash(text: str) -> str:
        """Compute SHA256 hash for allowlist lookup.

        Args:
            text: Text to hash (the detected "secret")

        Returns:
            Hash string in format "sha256:hexdigest"
        """
        digest = hashlib.sha256(text.encode()).hexdigest()
        return f"sha256:{digest}"

    def is_allowed(self, text: str) -> bool:
        """Check if text is on the allowlist.

        Args:
            text: Text to check

        Returns:
            True if allowlisted (and should not be redacted)
        """
        text_hash = self.compute_hash(text)
        return text_hash in self._entries

    def get_entry(self, text: str) -> Optional[AllowlistEntry]:
        """Get allowlist entry for text if exists.

        Args:
            text: Text to look up

        Returns:
            AllowlistEntry if found, None otherwise
        """
        text_hash = self.compute_hash(text)
        return self._entries.get(text_hash)

    def add(
        self,
        text: str,
        comment: str,
        added_by: str = "unknown",
    ) -> AllowlistEntry:
        """Add text to allowlist.

        Args:
            text: Text to allowlist (will be stored as hash only)
            comment: REQUIRED explanation of why this is safe
            added_by: Who is adding this entry

        Returns:
            The created AllowlistEntry

        Raises:
            ValueError: If comment is empty (required for audit)
        """
        if not comment or not comment.strip():
            raise ValueError("Comment is required when adding to allowlist")

        text_hash = self.compute_hash(text)
        entry = AllowlistEntry(
            hash=text_hash,
            comment=comment.strip(),
            added_date=datetime.now().isoformat(),
            added_by=added_by,
        )
        self._entries[text_hash] = entry
        self._save()
        return entry

    def remove(self, text: str) -> bool:
        """Remove text from allowlist.

        Args:
            text: Text to remove

        Returns:
            True if removed, False if wasn't in allowlist
        """
        text_hash = self.compute_hash(text)
        if text_hash in self._entries:
            del self._entries[text_hash]
            self._save()
            return True
        return False

    def list_entries(self) -> list[AllowlistEntry]:
        """List all allowlist entries.

        Returns:
            List of all entries (hashes, not original text)
        """
        return list(self._entries.values())

    @property
    def path(self) -> Path:
        """Return path to allowlist file."""
        return self._path


def is_allowlisted(
    text: str,
    project_root: Path | None = None,
) -> bool:
    """Convenience function to check if text is allowlisted.

    Args:
        text: Text to check
        project_root: Project root directory

    Returns:
        True if on allowlist
    """
    allowlist = Allowlist(project_root)
    return allowlist.is_allowed(text)
```

Update src/security/__init__.py to export:
- SecretDetector, detect_secrets_in_content from detector
- get_detection_type, get_confidence from patterns
- Allowlist, is_allowlisted from allowlist
  </action>
  <verify>
python -c "
from pathlib import Path
import tempfile
import os

from src.security.allowlist import Allowlist, is_allowlisted

# Test with temp directory
with tempfile.TemporaryDirectory() as tmpdir:
    root = Path(tmpdir)

    # Create allowlist
    allowlist = Allowlist(root)

    # Test empty allowlist
    assert not allowlist.is_allowed('some_secret'), 'Should not be allowed initially'

    # Add entry (requires comment)
    try:
        allowlist.add('fake_uuid_12345', '', 'tester')
        assert False, 'Should require comment'
    except ValueError:
        pass  # Expected

    # Add with comment
    entry = allowlist.add('fake_uuid_12345', 'Test fixture UUID, not a real secret', 'tester')
    assert entry.comment == 'Test fixture UUID, not a real secret'

    # Verify allowlisted
    assert allowlist.is_allowed('fake_uuid_12345'), 'Should be allowed now'
    assert not allowlist.is_allowed('different_text'), 'Different text not allowed'

    # Verify persisted
    allowlist2 = Allowlist(root)
    assert allowlist2.is_allowed('fake_uuid_12345'), 'Should persist'

    # Verify convenience function
    assert is_allowlisted('fake_uuid_12345', root), 'Convenience function should work'

print('Allowlist management OK')
"
  </verify>
  <done>
Allowlist works with hash-based storage. Comments are required for audit. Entries persist to .graphiti/allowlist.json. is_allowlisted convenience function works.
  </done>
</task>

</tasks>

<verification>
- [ ] `from src.security.detector import SecretDetector` works
- [ ] `from src.security.allowlist import Allowlist, is_allowlisted` works
- [ ] AWS-format strings are detected
- [ ] High-entropy strings are detected (aggressive thresholds)
- [ ] Allowlist requires comment for new entries
- [ ] Allowlist stores hashes, not plain text
</verification>

<success_criteria>
Plan complete when:
1. SecretDetector detects AWS keys, GitHub tokens, JWTs, and high-entropy strings
2. Detection uses aggressive entropy thresholds (3.5 base64, 2.5 hex)
3. Allowlist stores SHA256 hashes only (never plain text)
4. Allowlist requires comments for audit trail
5. All exports work from src.security package
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-filtering/02-03-SUMMARY.md`
</output>
