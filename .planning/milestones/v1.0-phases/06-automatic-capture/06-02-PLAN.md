---
phase: 06-automatic-capture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/__init__.py
  - src/hooks/installer.py
  - src/hooks/manager.py
  - src/hooks/templates/post-commit.sh
autonomous: true

must_haves:
  truths:
    - "Git post-commit hook template appends commit hash to pending file in 1-2ms"
    - "Hook installer detects existing hooks and appends non-destructively"
    - "Hook installer creates new hook with executable permissions when no existing hook"
    - "Already-installed hooks are detected and skipped (idempotent)"
    - "Hook manager can enable/disable hooks via config toggle"
    - "Hook manager can uninstall (remove graphiti section or whole hook)"
    - "Hook checks config on every run and exits if disabled"
  artifacts:
    - path: "src/hooks/__init__.py"
      provides: "Module exports for hook management"
      exports: ["install_hooks", "uninstall_hooks", "is_hook_installed", "set_hooks_enabled"]
    - path: "src/hooks/installer.py"
      provides: "Hook installation logic for git and Claude Code"
      contains: "install_git_hook"
    - path: "src/hooks/manager.py"
      provides: "Hook enable/disable/uninstall management"
      contains: "set_hooks_enabled"
    - path: "src/hooks/templates/post-commit.sh"
      provides: "Shell script template for git post-commit hook"
      contains: "GRAPHITI_HOOK"
  key_links:
    - from: "src/hooks/installer.py"
      to: "src/hooks/templates/post-commit.sh"
      via: "reads template file content"
      pattern: "templates.*post-commit"
    - from: "src/hooks/templates/post-commit.sh"
      to: "~/.graphiti/pending_commits"
      via: "echo append to signal file"
      pattern: "pending_commits"
    - from: "src/hooks/manager.py"
      to: "src/hooks/installer.py"
      via: "uninstall calls installer's detection logic"
      pattern: "from src\\.hooks\\.installer"
---

<objective>
Build the hook installation and management system: shell script templates for git post-commit hook, installer with non-destructive existing hook handling, and manager for enable/disable/uninstall operations.

Purpose: Provides the mechanism to install, configure, and remove automatic capture triggers in git repositories and Claude Code sessions.
Output: `src/hooks/` package with installer.py, manager.py, templates/post-commit.sh
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automatic-capture/06-CONTEXT.md
@.planning/phases/06-automatic-capture/06-RESEARCH.md
@src/config/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook templates and installer</name>
  <files>
    src/hooks/__init__.py
    src/hooks/installer.py
    src/hooks/templates/post-commit.sh
  </files>
  <action>
Create the `src/hooks/` package with templates and installer:

**src/hooks/templates/post-commit.sh** - Git post-commit hook template:
```sh
#!/bin/sh
# === Graphiti Capture Hook ===
# Auto-installed by graphiti - captures commit hashes for background processing
# To disable: graphiti config set hooks.enabled false
# To remove: graphiti hooks uninstall

# GRAPHITI_HOOK_START
# Check if capture is enabled via config
if command -v graphiti >/dev/null 2>&1; then
  if ! graphiti config get hooks.enabled 2>/dev/null | grep -q "true"; then
    exit 0
  fi
else
  # graphiti not in PATH, skip silently
  exit 0
fi

# Append current commit hash to pending file
COMMIT_HASH=$(git rev-parse HEAD)
PENDING_FILE="${HOME}/.graphiti/pending_commits"

# Ensure directory exists
mkdir -p "$(dirname "$PENDING_FILE")"

# Atomic append (O_APPEND semantics for small writes)
echo "$COMMIT_HASH" >> "$PENDING_FILE"
# GRAPHITI_HOOK_END

exit 0
```

The template uses `GRAPHITI_HOOK_START` and `GRAPHITI_HOOK_END` markers so the installer can detect and replace/remove our section in existing hooks. The hook checks `graphiti config get hooks.enabled` on every run (per locked decision: config toggle).

**src/hooks/installer.py** - Hook installation logic:
- `HOOK_START_MARKER = "# GRAPHITI_HOOK_START"`
- `HOOK_END_MARKER = "# GRAPHITI_HOOK_END"`
- `_get_hook_template() -> str`: Read the post-commit.sh template from the templates directory using `Path(__file__).parent / "templates" / "post-commit.sh"`. Return the content.
- `_get_graphiti_section() -> str`: Extract just the section between GRAPHITI_HOOK_START and GRAPHITI_HOOK_END markers (inclusive) from the template. This is what gets appended to existing hooks.
- `is_git_hook_installed(repo_path: Path) -> bool`: Check if `.git/hooks/post-commit` exists AND contains `GRAPHITI_HOOK_START` marker. Returns True if already installed. Handles both standalone and appended installations.
- `install_git_hook(repo_path: Path, force: bool = False) -> bool`: Install post-commit hook non-destructively (per locked decision: existing hooks handling at Claude's discretion -- append approach per research recommendation):
  1. Verify `repo_path / ".git"` exists (raise ValueError if not a git repo)
  2. Check `is_git_hook_installed()` -- if already installed, log and return False (idempotent)
  3. Get hook path: `repo_path / ".git/hooks/post-commit"`
  4. If hook_path exists (existing hook from another tool):
     - Read existing content
     - Detect pre-commit framework: check for `# pre-commit` or `pre-commit hook` marker. If found, log warning suggesting pre-commit integration but still append.
     - Append our section: write `\n\n` + full graphiti section (from `_get_graphiti_section()`) to end of file
  5. If hook_path does not exist:
     - Ensure `.git/hooks/` directory exists
     - Write full template content (includes shebang line)
  6. Set executable permission: `hook_path.chmod(0o755)`
  7. Log success via structlog, return True
- `uninstall_git_hook(repo_path: Path) -> bool`: Remove graphiti section from hook:
  1. Check if installed -- if not, return False
  2. Read hook content
  3. If hook ONLY contains graphiti content (was standalone install): remove the entire file
  4. If hook contains other content: remove section between GRAPHITI_HOOK_START and GRAPHITI_HOOK_END (inclusive, plus surrounding blank lines), write back remaining content
  5. Return True
- `install_claude_hook(project_path: Path) -> bool`: Create/update `.claude/settings.json` (project-local, not global) with Stop hook configuration for auto-capture. The hook command is: `graphiti capture --auto --transcript-path "$transcript_path" --session-id "$session_id"`. Set `async: true` and `timeout: 10`. If settings.json exists, merge hooks into existing config (don't overwrite other settings). If hooks.Stop already has graphiti entry, skip (idempotent). Return True if installed, False if already exists. Use json module for reading/writing.
- `uninstall_claude_hook(project_path: Path) -> bool`: Remove graphiti entry from `.claude/settings.json` hooks.Stop array. If it's the only Stop hook, remove the Stop key. If no hooks remain, remove the hooks key. Return True if removed.

Use structlog for all logging. Import Path from pathlib.

**src/hooks/__init__.py** - Package exports:
- Export: `install_git_hook`, `uninstall_git_hook`, `is_git_hook_installed`, `install_claude_hook`, `uninstall_claude_hook`
- Will be extended in Task 2 with manager exports.
  </action>
  <verify>
Run: `python -c "from src.hooks import install_git_hook, uninstall_git_hook, is_git_hook_installed, install_claude_hook, uninstall_claude_hook; print('All imports OK')"` -- imports work.
Run: `python -c "from src.hooks.installer import _get_hook_template; t = _get_hook_template(); assert 'GRAPHITI_HOOK_START' in t; assert 'pending_commits' in t; assert 'hooks.enabled' in t; print('Template OK')"` -- template loads with required content.
Run: `python -c "from src.hooks.installer import is_git_hook_installed; from pathlib import Path; assert not is_git_hook_installed(Path('/tmp')); print('Detection OK')"` -- detection works on non-git dir.
  </verify>
  <done>
post-commit.sh template appends commit hash to ~/.graphiti/pending_commits with config check on every run. installer.py handles: detecting existing hooks, appending non-destructively with markers, standalone installation with executable permissions, idempotent detection, Claude Code settings.json Stop hook configuration. All exports in __init__.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hook manager for enable/disable/uninstall operations</name>
  <files>
    src/hooks/manager.py
    src/hooks/__init__.py
  </files>
  <action>
**src/hooks/manager.py** - Hook lifecycle management:
- `def get_hooks_enabled() -> bool`: Read hooks.enabled from graphiti config. Use `subprocess.run(["graphiti", "config", "get", "hooks.enabled"], capture_output=True, text=True, timeout=5)`. Parse output: if stdout contains "true" return True, otherwise False. If subprocess fails (graphiti not in PATH, config key missing), default to True (enabled by default per convention -- hooks are installed intentionally).
- `def set_hooks_enabled(enabled: bool) -> None`: Set hooks.enabled in graphiti config. Use `subprocess.run(["graphiti", "config", "set", "hooks.enabled", str(enabled).lower()], capture_output=True, text=True, timeout=5)`. Log the change via structlog.
- `def install_hooks(repo_path: Path, install_git: bool = True, install_claude: bool = True) -> dict`: Install both hook types (per locked decision: both hook types in this phase). Returns dict with `{"git_hook": bool, "claude_hook": bool}` indicating what was installed. Calls `install_git_hook()` and `install_claude_hook()`. Ensures hooks.enabled is set to True in config. Catches individual errors -- if one fails, still try the other. Log results.
- `def uninstall_hooks(repo_path: Path, remove_git: bool = True, remove_claude: bool = True) -> dict`: Uninstall specified hook types. Returns dict with `{"git_hook": bool, "claude_hook": bool}` indicating what was removed. Calls `uninstall_git_hook()` and `uninstall_claude_hook()`.
- `def get_hook_status(repo_path: Path) -> dict`: Return status dict with:
  - `"hooks_enabled"`: bool from config
  - `"git_hook_installed"`: bool from is_git_hook_installed()
  - `"claude_hook_installed"`: bool (check if .claude/settings.json has graphiti Stop hook)
  - `"repo_path"`: str(repo_path)

Import installer functions from `src.hooks.installer`. Use structlog for logging.

**Update src/hooks/__init__.py** to add manager exports:
- Add: `install_hooks`, `uninstall_hooks`, `get_hook_status`, `set_hooks_enabled`, `get_hooks_enabled`
  </action>
  <verify>
Run: `python -c "from src.hooks import install_hooks, uninstall_hooks, get_hook_status, set_hooks_enabled, get_hooks_enabled; print('All manager exports OK')"` -- all exports work.
Run: `python -c "from src.hooks.manager import get_hook_status; from pathlib import Path; status = get_hook_status(Path('.')); print(status); assert 'hooks_enabled' in status; assert 'git_hook_installed' in status; print('Status OK')"` -- status check works.
  </verify>
  <done>
manager.py provides install_hooks() for both git+claude hooks, uninstall_hooks() for removal, get_hook_status() for status reporting, and set_hooks_enabled()/get_hooks_enabled() for config toggle. All operations are idempotent and handle individual failures gracefully. Package __init__.py exports all public manager functions.
  </done>
</task>

</tasks>

<verification>
1. `python -c "import src.hooks; print(dir(src.hooks))"` -- shows all expected exports
2. Template file exists at `src/hooks/templates/post-commit.sh` and contains GRAPHITI_HOOK_START/END markers
3. Template contains `hooks.enabled` config check
4. Template contains `pending_commits` file append
5. `python -c "from src.hooks.installer import _get_graphiti_section; s = _get_graphiti_section(); assert 'GRAPHITI_HOOK_START' in s; assert 'GRAPHITI_HOOK_END' in s; print('Section extraction OK')"` -- section extraction works
</verification>

<success_criteria>
- src/hooks/ package exists with installer.py, manager.py, templates/post-commit.sh, __init__.py
- Post-commit hook template checks hooks.enabled config on every run (locked decision)
- Hook installer appends non-destructively to existing hooks (Claude's discretion: append strategy)
- Hook installer is idempotent (detects already-installed via markers)
- Hook installer sets executable permissions (0o755)
- Claude Code Stop hook configured with async:true, timeout:10
- Manager provides enable/disable toggle via config
- Manager provides install/uninstall for both hook types (locked decision)
- get_hook_status() reports installation state for both hook types
</success_criteria>

<output>
After completion, create `.planning/phases/06-automatic-capture/06-02-SUMMARY.md`
</output>
