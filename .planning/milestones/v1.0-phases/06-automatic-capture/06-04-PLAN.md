---
phase: 06-automatic-capture
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/cli/commands/capture.py
  - src/cli/commands/hooks.py
  - src/cli/commands/add.py
  - src/cli/__init__.py
autonomous: true

must_haves:
  truths:
    - "'graphiti capture' reads recent conversation context and stores it"
    - "'graphiti capture --auto' processes only new turns since last capture"
    - "'graphiti hooks install' installs both git and Claude Code hooks"
    - "'graphiti hooks uninstall' removes both hook types"
    - "'graphiti hooks status' shows hook installation and enable state"
    - "First 'graphiti add' in a project auto-installs hooks (locked decision)"
    - "All new commands appear in 'graphiti --help'"
  artifacts:
    - path: "src/cli/commands/capture.py"
      provides: "CLI capture command for manual and auto conversation capture"
      contains: "capture_command"
    - path: "src/cli/commands/hooks.py"
      provides: "CLI hooks command group for install/uninstall/status"
      contains: "hooks_app"
    - path: "src/cli/commands/add.py"
      provides: "Modified add command with auto-install hooks on first use"
      contains: "install_hooks"
    - path: "src/cli/__init__.py"
      provides: "Updated command registry with capture and hooks commands"
      contains: "capture_command"
  key_links:
    - from: "src/cli/commands/capture.py"
      to: "src/capture/conversation.py"
      via: "calls capture_conversation and capture_manual"
      pattern: "from src\\.capture"
    - from: "src/cli/commands/hooks.py"
      to: "src/hooks/manager.py"
      via: "calls install_hooks, uninstall_hooks, get_hook_status"
      pattern: "from src\\.hooks"
    - from: "src/cli/commands/add.py"
      to: "src/hooks/installer.py"
      via: "auto-install hooks on first add"
      pattern: "from src\\.hooks"
---

<objective>
Build CLI commands for capture and hook management, and wire auto-install hooks into the existing add command. This plan connects all capture and hook infrastructure to the user-facing CLI.

Purpose: Provides the user interface for manual capture, hook management, and enables automatic hook installation on first use.
Output: src/cli/commands/capture.py, src/cli/commands/hooks.py, modified add.py and cli/__init__.py
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automatic-capture/06-CONTEXT.md
@.planning/phases/06-automatic-capture/06-RESEARCH.md
@.planning/phases/06-automatic-capture/06-01-SUMMARY.md
@.planning/phases/06-automatic-capture/06-02-SUMMARY.md
@src/cli/__init__.py
@src/cli/commands/add.py
@src/cli/commands/queue_cmd.py
@src/cli/output.py
@src/cli/utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create capture and hooks CLI commands</name>
  <files>
    src/cli/commands/capture.py
    src/cli/commands/hooks.py
  </files>
  <action>
**src/cli/commands/capture.py** - Manual and auto capture command:

Follow the established CLI command patterns from add.py and queue_cmd.py.

```python
def capture_command(
    auto: bool = typer.Option(False, "--auto", help="Auto-capture mode (incremental, for hooks)"),
    transcript_path: Optional[str] = typer.Option(None, "--transcript-path", help="Path to Claude Code transcript JSONL"),
    session_id: Optional[str] = typer.Option(None, "--session-id", help="Claude Code session ID for tracking"),
    format: Optional[str] = typer.Option(None, "--format", "-f", help="Output format: json"),
    quiet: bool = typer.Option(False, "--quiet", "-q", help="Suppress output"),
):
```

Implementation:
1. If `auto` mode (called from Stop hook):
   - Require both transcript_path and session_id (raise BadParameter if missing)
   - Call `capture_conversation(Path(transcript_path), session_id, auto=True)` from src.capture.conversation
   - Use `run_graph_operation()` wrapper for async call
   - If result is None (no new turns), exit quietly
   - Output result or exit silently based on quiet/format flags
2. If manual mode (user runs `graphiti capture`):
   - Call `capture_manual(Path(transcript_path) if transcript_path else None)` from src.capture.conversation
   - Use `run_graph_operation()` wrapper for async call
   - Display success message with entity info
3. Error handling: catch ValueError (no transcript found) with helpful message suggesting the user run this inside a Claude Code session. Catch LLMUnavailableError with message directing to `graphiti health`.

Help text: "Capture knowledge from the current Claude Code conversation."
Examples in docstring:
- `graphiti capture` (manual capture of current session)
- `graphiti capture --auto --transcript-path /path/to/transcript --session-id abc123` (hook-triggered)

**src/cli/commands/hooks.py** - Hook management command group:

Use Typer command group pattern (same as queue_cmd.py with `app.add_typer`):

```python
hooks_app = typer.Typer(help="Manage automatic capture hooks")
```

Subcommands:

`@hooks_app.command(name="install")`
```python
def install_command(
    git_only: bool = typer.Option(False, "--git-only", help="Install only git hooks"),
    claude_only: bool = typer.Option(False, "--claude-only", help="Install only Claude Code hooks"),
    force: bool = typer.Option(False, "--force", help="Force reinstall even if already installed"),
    format: Optional[str] = typer.Option(None, "--format", "-f", help="Output format: json"),
):
```
- Resolve current project path via `resolve_scope()` (need project root for hook installation)
- Call `install_hooks(repo_path, install_git=not claude_only, install_claude=not git_only)` from src.hooks
- Display result: what was installed, what was skipped (already installed)

`@hooks_app.command(name="uninstall")`
```python
def uninstall_command(
    git_only: bool = typer.Option(False, "--git-only", help="Remove only git hooks"),
    claude_only: bool = typer.Option(False, "--claude-only", help="Remove only Claude Code hooks"),
    format: Optional[str] = typer.Option(None, "--format", "-f", help="Output format: json"),
):
```
- Resolve project path
- Call `uninstall_hooks(repo_path, remove_git=not claude_only, remove_claude=not git_only)` from src.hooks
- Display result: what was removed

`@hooks_app.command(name="status")`
```python
def status_command(
    format: Optional[str] = typer.Option(None, "--format", "-f", help="Output format: json"),
):
```
- Resolve project path
- Call `get_hook_status(repo_path)` from src.hooks
- Display: hooks enabled/disabled, git hook installed/not, claude hook installed/not
- Use Rich formatting (checkmarks/X marks) for non-JSON output, matching queue status pattern

Import from src.hooks: install_hooks, uninstall_hooks, get_hook_status, set_hooks_enabled. Import from src.cli.output: console, print_success, print_error, print_json. Import from src.cli.utils: resolve_scope, EXIT_SUCCESS, EXIT_ERROR.
  </action>
  <verify>
Run: `python -c "from src.cli.commands.capture import capture_command; print('capture command OK')"` -- capture command loads.
Run: `python -c "from src.cli.commands.hooks import hooks_app; print('hooks app OK')"` -- hooks command group loads.
Run: `graphiti capture --help 2>/dev/null || python -m src.cli capture --help 2>/dev/null || echo 'Help text check deferred to Task 2 registration'"` -- help text available (may need registration first).
Run: `graphiti hooks --help 2>/dev/null || echo 'Help text check deferred to Task 2 registration'"` -- hooks help (may need registration).
  </verify>
  <done>
capture.py provides `graphiti capture` with auto mode (for Stop hook) and manual mode (for user). hooks.py provides `graphiti hooks` command group with install/uninstall/status subcommands. Both follow established CLI patterns (Typer, Rich output, JSON format support).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auto-install into add command and register new commands</name>
  <files>
    src/cli/commands/add.py
    src/cli/__init__.py
  </files>
  <action>
**Modify src/cli/commands/add.py** - Add auto-install hooks on first `graphiti add`:

Per locked decision: "Auto-install on first `graphiti add`: When user first runs `graphiti add` in a project, automatically install the post-commit hook. Frictionless, no extra step."

Add a new helper function `_auto_install_hooks(project_root: Path) -> None`:
1. Import `is_git_hook_installed`, `install_hooks` from `src.hooks`
2. Check if git hook is already installed: `is_git_hook_installed(project_root)`
3. If already installed, return immediately (no-op)
4. Check if `.git` directory exists in project_root (only install in git repos)
5. If not a git repo, return (don't try to install hooks in non-git directories)
6. Call `install_hooks(project_root, install_git=True, install_claude=True)` -- both types per locked decision
7. Log the auto-installation via structlog (not console output -- should be transparent to user during add)
8. Wrap entire function in try/except: if hook installation fails for any reason, log warning but do NOT fail the add operation. Hook installation is best-effort during auto-install.

In `add_command()`, add a call to `_auto_install_hooks(root)` AFTER step 4 (auto-init .graphiti/ directory) but BEFORE step 5 (add entity):
```python
# 4. Auto-init .graphiti/ directory for project scope
if scope == GraphScope.PROJECT and root:
    _ensure_project_directory(root)

# 4.5 Auto-install hooks on first add (best-effort)
if root:
    _auto_install_hooks(root)

# 5. Add entity with spinner
```

The auto-install runs for ALL scopes when a project root is detected (not just PROJECT scope), because git hooks should capture regardless of which scope the user is adding to.

Add import at top: `from src.hooks import is_git_hook_installed, install_hooks`

**Modify src/cli/__init__.py** - Register new commands:

Add imports:
```python
from src.cli.commands.capture import capture_command
from src.cli.commands.hooks import hooks_app
```

Register capture command:
```python
app.command(name="capture", help="Capture knowledge from conversations")(capture_command)
```

Register hooks command group (same pattern as queue_app):
```python
app.add_typer(hooks_app, name="hooks", help="Manage automatic capture hooks")
```

Update the final comment to reflect the new command count:
```python
# All 12 commands registered: add, search, list, show, delete, summarize, compact, config, health, queue (group), capture, hooks (group)
```
  </action>
  <verify>
Run: `graphiti --help` -- should show capture and hooks in command list.
Run: `graphiti capture --help` -- should show capture command options (--auto, --transcript-path, --session-id, --format, --quiet).
Run: `graphiti hooks --help` -- should show hooks subcommands (install, uninstall, status).
Run: `graphiti hooks status` -- should show current hook status (likely not installed yet).
Run: `python -c "from src.cli.commands.add import _auto_install_hooks; print('Auto-install hook function exists')"` -- auto-install function accessible.
  </verify>
  <done>
add.py auto-installs hooks on first `graphiti add` in any git project (best-effort, never fails the add operation). CLI __init__.py registers capture command and hooks command group. `graphiti --help` shows all 12 commands. `graphiti capture` works for manual/auto modes. `graphiti hooks install/uninstall/status` manages hook lifecycle.
  </done>
</task>

</tasks>

<verification>
1. `graphiti --help` shows capture and hooks commands
2. `graphiti capture --help` shows --auto, --transcript-path, --session-id options
3. `graphiti hooks --help` shows install, uninstall, status subcommands
4. `graphiti hooks status` runs without error and shows hook state
5. `python -c "from src.cli.commands.add import _auto_install_hooks; from pathlib import Path; print('OK')"` -- auto-install function exists
6. `python -c "from src.cli.commands.capture import capture_command; from src.cli.commands.hooks import hooks_app; print('Commands OK')"` -- both modules load
</verification>

<success_criteria>
- `graphiti capture` works for manual conversation capture (locked decision: no-args reads current session)
- `graphiti capture --auto` works for hook-triggered incremental capture
- `graphiti hooks install` installs both git and Claude Code hooks (locked decision)
- `graphiti hooks uninstall` removes hooks (locked decision: both CLI and config toggle)
- `graphiti hooks status` shows installation state
- First `graphiti add` in a project auto-installs hooks (locked decision: frictionless)
- Auto-install is best-effort (never fails the add operation)
- All commands registered and appear in help output
- JSON format option available on all commands
</success_criteria>

<output>
After completion, create `.planning/phases/06-automatic-capture/06-04-SUMMARY.md`
</output>
