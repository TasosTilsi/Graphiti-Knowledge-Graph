---
phase: 04-cli-interface
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/service.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "graphiti summarize produces an LLM-generated summary of knowledge graph contents"
    - "graphiti compact identifies and merges duplicate entities, reporting merge statistics"
  artifacts:
    - path: "src/graph/service.py"
      provides: "Working implementations of summarize and compact methods"
      contains: "ollama_chat"
  key_links:
    - from: "GraphService.summarize()"
      to: "EntityNode.get_by_group_ids()"
      via: "Loads entities then builds LLM prompt"
      pattern: "EntityNode\\.get_by_group_ids"
    - from: "GraphService.summarize()"
      to: "ollama_chat"
      via: "Sends entity summary prompt to LLM"
      pattern: "ollama_chat"
    - from: "GraphService.compact()"
      to: "driver.execute_query"
      via: "Queries for duplicate entities and merges them"
      pattern: "execute_query"
---

<objective>
Implement the 2 remaining GraphService methods (summarize, compact) that require LLM interaction and complex logic beyond simple Kuzu queries.

Purpose: summarize() powers the `graphiti summarize` command that generates human-readable knowledge graph summaries. compact() powers the `graphiti compact` command that deduplicates entities to keep the graph clean.

Output: Working implementations in src/graph/service.py that load entities, call LLM for summarization, and perform entity deduplication.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-interface/04-07-SUMMARY.md

Source files:
@src/graph/service.py
@src/llm/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement summarize method</name>
  <files>src/graph/service.py</files>
  <action>
Replace the placeholder implementation of summarize() in GraphService with real entity loading and LLM-powered summarization.

**summarize() (currently lines 437-441):**

The method should:
1. Load entities from the graph for the given scope
2. Optionally filter by topic
3. Build a prompt with entity names and summaries
4. Send to LLM via ollama_chat() (already imported as `from src.llm import chat as ollama_chat`)
5. Return (summary_text, entity_count)

Implementation:
1. Get graphiti instance and group_id (same pattern as other methods):
   ```python
   graphiti = self._get_graphiti(scope, project_root)
   group_id = self._get_group_id(scope, project_root)
   ```
2. Load entities using EntityNode.get_by_group_ids (EntityNode should already be imported after Plan 04-10):
   ```python
   entities = await EntityNode.get_by_group_ids(
       graphiti.driver, group_ids=[group_id], limit=200
   )
   ```
   Use limit=200 to avoid overwhelming the LLM context. If no entities found, return ("No entities found in the knowledge graph.", 0).
3. If topic is provided, filter entities whose name or summary contains the topic (case-insensitive):
   ```python
   if topic:
       filtered = [
           e for e in entities
           if topic.lower() in e.name.lower()
           or (e.summary and topic.lower() in e.summary.lower())
       ]
       if filtered:
           entities = filtered
       # If no matches for topic filter, use all entities but note it in the prompt
   ```
4. Build the LLM prompt from entity data:
   ```python
   entity_descriptions = []
   for e in entities[:100]:  # Cap at 100 entities for LLM context
       desc = f"- {e.name}"
       if e.summary:
           desc += f": {e.summary}"
       if e.labels:
           desc += f" (labels: {', '.join(e.labels)})"
       entity_descriptions.append(desc)

   entity_text = "\n".join(entity_descriptions)

   topic_clause = f" focusing on '{topic}'" if topic else ""
   prompt = (
       f"Summarize the following knowledge graph entities{topic_clause}. "
       f"Provide a concise, readable overview of what knowledge is stored. "
       f"Focus on key themes, relationships between concepts, and notable patterns.\n\n"
       f"Entities ({len(entities)} total):\n{entity_text}"
   )
   ```
5. Call ollama_chat via run_in_executor (since ollama_chat is sync and we're in async context):
   ```python
   import asyncio
   loop = asyncio.get_event_loop()
   response = await loop.run_in_executor(
       None,
       lambda: ollama_chat(messages=[{"role": "user", "content": prompt}]),
   )
   summary_text = response["message"]["content"]
   ```
   Note: asyncio is already imported at the module level.
6. Return `(summary_text, len(entities))`.
7. Wrap the LLM call in try/except for LLMUnavailableError (already imported):
   ```python
   try:
       # ... LLM call ...
   except LLMUnavailableError:
       # Fall back to a non-LLM summary
       entity_names = [e.name for e in entities[:20]]
       fallback = f"Knowledge graph contains {len(entities)} entities"
       if topic:
           fallback += f" (filtered by '{topic}')"
       fallback += f". Key entities: {', '.join(entity_names)}"
       if len(entities) > 20:
           fallback += f"... and {len(entities) - 20} more"
       return (fallback, len(entities))
   ```
8. Remove the TODO comment and logger.warning("summarize not yet implemented...") line.

**Important notes:**
- `ollama_chat` is already imported as `from src.llm import chat as ollama_chat` at the module top.
- `LLMUnavailableError` is already imported as `from src.llm import LLMUnavailableError`.
- `asyncio` is already imported at the module top.
- The run_in_executor pattern is the same one used in the adapter layer (OllamaLLMClient).
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
source = inspect.getsource(GraphService.summarize)
assert 'TODO' not in source, 'summarize still has TODO'
assert 'not yet implemented' not in source, 'summarize still has placeholder warning'
assert 'ollama_chat' in source or 'EntityNode' in source, 'summarize has no LLM or entity logic'
print('summarize checks passed')
"` should print "summarize checks passed".
  </verify>
  <done>summarize() loads entities via EntityNode.get_by_group_ids(), optionally filters by topic, builds an LLM prompt with entity names and summaries, calls ollama_chat for a readable summary, and falls back to a non-LLM entity listing if LLM is unavailable. Returns (summary_text, entity_count) tuple.</done>
</task>

<task type="auto">
  <name>Task 2: Implement compact method</name>
  <files>src/graph/service.py</files>
  <action>
Replace the placeholder implementation of compact() in GraphService with real entity deduplication logic.

**compact() (currently lines 459-466):**

The compact operation should find entities with similar or identical names and merge them. This is a graph maintenance operation.

Implementation:
1. Get graphiti instance, driver, and group_id:
   ```python
   graphiti = self._get_graphiti(scope, project_root)
   driver = graphiti.driver
   group_id = self._get_group_id(scope, project_root)
   ```
2. Load all entities:
   ```python
   entities = await EntityNode.get_by_group_ids(
       driver, group_ids=[group_id], limit=1000
   )
   original_count = len(entities)
   ```
3. If no entities or only one entity, return early:
   ```python
   if len(entities) <= 1:
       return {
           "merged_count": 0,
           "removed_count": 0,
           "new_entity_count": original_count,
           "new_size_bytes": 0,
       }
   ```
4. Find duplicates by grouping entities with identical lowercased names:
   ```python
   from collections import defaultdict
   name_groups: dict[str, list] = defaultdict(list)
   for entity in entities:
       name_groups[entity.name.lower().strip()].append(entity)

   # Groups with more than 1 entity are duplicates
   duplicate_groups = {k: v for k, v in name_groups.items() if len(v) > 1}
   ```
   Note: Add `from collections import defaultdict` at the top of the file if not already imported.
5. For each duplicate group, keep the entity with the most information (longest summary) and delete the rest:
   ```python
   removed_count = 0
   merged_count = 0
   for name_key, group in duplicate_groups.items():
       # Sort by summary length descending - keep the most complete entity
       group.sort(key=lambda e: len(e.summary or ""), reverse=True)
       keep = group[0]  # Entity with most information
       to_remove = group[1:]  # Duplicates to delete

       if to_remove:
           # For each entity being removed, re-point its relationships to the kept entity
           # In Kuzu's schema, relationships go through RelatesToNode_ nodes
           # We delete the duplicate entity nodes (their edges become orphaned and are cleaned up)
           uuids_to_remove = [e.uuid for e in to_remove]
           await Node.delete_by_uuids(driver, uuids_to_remove)
           removed_count += len(to_remove)
           merged_count += 1
   ```
6. Get new entity count after compaction:
   ```python
   remaining = await EntityNode.get_by_group_ids(
       driver, group_ids=[group_id]
   )
   new_entity_count = len(remaining)
   ```
7. Get database size (reuse pattern from get_stats if available, or compute inline):
   ```python
   import os
   size_bytes = 0
   db_path = None
   if hasattr(driver, 'db') and hasattr(driver.db, 'database_path'):
       db_path = str(driver.db.database_path)
   else:
       if scope == GraphScope.GLOBAL:
           db_path = str(GLOBAL_DB_PATH)
       elif project_root:
           db_path = str(get_project_db_path(project_root))
   if db_path:
       try:
           for dirpath, dirnames, filenames in os.walk(db_path):
               for f in filenames:
                   fp = os.path.join(dirpath, f)
                   size_bytes += os.path.getsize(fp)
       except OSError:
           size_bytes = 0
   ```
   Note: `os` should already be imported after Plan 04-10 Task 2. `GLOBAL_DB_PATH` and `get_project_db_path` are already imported.
8. Return the result dict:
   ```python
   return {
       "merged_count": merged_count,
       "removed_count": removed_count,
       "new_entity_count": new_entity_count,
       "new_size_bytes": size_bytes,
   }
   ```
9. Wrap in try/except, log errors, raise.
10. Remove the TODO comment and logger.warning("compact not yet implemented...") line.

**Consider extracting a _get_db_size helper:** Since both get_stats() (from Plan 04-10) and compact() need to compute database size, consider extracting a private method `_get_db_size(self, scope, project_root, driver)` to avoid duplication. If you do this, update get_stats() to use it too. This is optional but encouraged for code cleanliness.

**Important notes:**
- `from collections import defaultdict` needs to be added if not present.
- `Node` should already be imported from Plan 04-10 (`from graphiti_core.nodes import EntityNode, EpisodeType, Node`).
- `os` should already be imported from Plan 04-10.
- The deduplication is name-based (exact case-insensitive match). Fuzzy/embedding-based dedup is deferred to Phase 9 Advanced Features.
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
source = inspect.getsource(GraphService.compact)
assert 'TODO' not in source, 'compact still has TODO'
assert 'not yet implemented' not in source, 'compact still has placeholder warning'
assert 'delete' in source.lower() or 'remove' in source.lower(), 'compact has no deletion logic'
print('compact checks passed')
"` should print "compact checks passed".

Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && .venv/bin/python -c "
import inspect
from src.graph.service import GraphService
# Final verification: NO placeholder methods remain anywhere in GraphService
for method_name in ['list_entities', 'get_entity', 'delete_entities', 'summarize', 'compact', 'get_stats']:
    source = inspect.getsource(getattr(GraphService, method_name))
    assert 'not yet implemented' not in source, f'{method_name} still has placeholder'
    assert 'TODO' not in source, f'{method_name} still has TODO'
print('ALL 6 placeholder methods are now fully implemented')
"` should print "ALL 6 placeholder methods are now fully implemented".
  </verify>
  <done>compact() loads all entities, groups them by lowercased name, identifies duplicate groups, keeps the entity with the most complete summary, deletes duplicates via Node.delete_by_uuids(), and returns merge statistics (merged_count, removed_count, new_entity_count, new_size_bytes). No placeholder methods remain in GraphService.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `from src.graph.service import GraphService` imports without error
2. No TODO comments remain in any of the 6 previously-placeholder methods
3. No "not yet implemented" warnings remain in any method
4. summarize() contains ollama_chat call with entity-based prompt
5. compact() contains duplicate detection and Node.delete_by_uuids() call
6. Import statements at top of file are clean
7. All 8 GraphService methods (add, search, list_entities, get_entity, delete_entities, summarize, compact, get_stats) have real implementations
</verification>

<success_criteria>
- summarize() loads entities via EntityNode.get_by_group_ids(), builds LLM prompt, calls ollama_chat, returns (summary_text, entity_count)
- summarize() has LLMUnavailableError fallback that returns entity listing without LLM
- summarize() supports optional topic filter
- compact() finds duplicate entities by case-insensitive name matching
- compact() keeps most-informative entity (longest summary), deletes duplicates via graphiti_core API
- compact() returns accurate merge statistics including database size
- Zero placeholder/TODO comments remain across all 6 previously-placeholder GraphService methods
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-11-SUMMARY.md`
</output>
