---
phase: 04-cli-interface
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli/commands/summarize.py
  - src/cli/commands/compact.py
autonomous: true

must_haves:
  truths:
    - "User can run 'graphiti summarize' for whole-graph summary"
    - "User can run 'graphiti summarize topic' for focused topic summary"
    - "User can run 'graphiti compact' to compact the knowledge graph"
    - "Compact shows confirmation prompt (destructive operation)"
    - "Compact with --force skips confirmation"
    - "Both commands show spinner during long operations"
    - "--format json works for both commands"
  artifacts:
    - path: "src/cli/commands/summarize.py"
      provides: "Summarize command for whole-graph and topic-focused summaries"
      exports: ["summarize_command"]
    - path: "src/cli/commands/compact.py"
      provides: "Compact command with confirmation prompt for graph compaction"
      exports: ["compact_command"]
  key_links:
    - from: "src/cli/commands/summarize.py"
      to: "src/llm/__init__.py"
      via: "Uses chat() or generate() for LLM-powered summarization"
      pattern: "from src\\.llm import"
    - from: "src/cli/commands/compact.py"
      to: "src/cli/utils.py"
      via: "confirm_action for destructive operation"
      pattern: "confirm_action"
    - from: "src/cli/commands/summarize.py"
      to: "src/cli/output.py"
      via: "console.status for spinner, console.print for rich summary"
      pattern: "console\\.status|console\\.print"
---

<objective>
Implement the summarize and compact CLI commands. Summarize uses LLM to generate knowledge graph summaries (whole graph or focused on a topic). Compact merges and deduplicates graph content as a maintenance operation.

Purpose: Summarize is a key differentiator -- it leverages the LLM to synthesize knowledge. Compact is an essential maintenance command for graph hygiene. Both involve long-running operations requiring spinners and proper feedback.

Output: Working `graphiti summarize` and `graphiti compact` commands.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-cli-interface/04-CONTEXT.md
@.planning/phases/04-cli-interface/04-RESEARCH.md
@.planning/phases/04-cli-interface/04-01-SUMMARY.md
@src/cli/__init__.py
@src/cli/output.py
@src/cli/utils.py
@src/llm/__init__.py
@src/llm/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement summarize command</name>
  <files>src/cli/commands/summarize.py</files>
  <action>
Create `src/cli/commands/summarize.py`:

Function signature:
```
def summarize_command(
    topic: Annotated[Optional[str], typer.Argument(help="Topic to summarize (omit for whole graph)")] = None,
    global_scope: Annotated[bool, typer.Option("--global", "-g")] = False,
    project_scope: Annotated[bool, typer.Option("--project", "-p")] = False,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
    quiet: Annotated[bool, typer.Option("--quiet", "-q")] = False,
)
```

Implementation:
1. Resolve scope.
2. Determine mode: if topic is None, whole-graph summary. Else focused summary on topic.
3. Spinner with dynamic status:
   - Whole graph: `console.status("Summarizing knowledge graph...")` with update `"Summarizing {n} entities..."` (after loading entity count).
   - Focused: `console.status(f"Summarizing knowledge about '{topic}'...")`.
4. Load relevant entities from graph (stub `_load_entities(scope, topic)` returning mock list).
5. If no entities found: print_warning("No knowledge found to summarize.") if topic is None, or print_warning(f"No knowledge found about '{topic}'.") and exit 0.
6. Call LLM to generate summary (stub `_generate_summary(entities, topic)` that:
   - Constructs a prompt like: "Summarize the following knowledge graph entities: {entities}. Focus on key decisions, patterns, and relationships."
   - If topic: add "Focus specifically on: {topic}"
   - For now, return a mock summary string so the CLI flow is testable. Include a TODO comment: `# TODO: Wire to actual LLM via src.llm.chat() when graph read operations available`.
7. Output:
   - format=="json": print_json({"summary": summary_text, "scope": scope.value, "topic": topic, "entity_count": len(entities)}).
   - default: Use Rich Panel or Markdown rendering: title=f"Knowledge Summary{' - ' + topic if topic else ''}", body=summary text. Print entity count below panel.
8. Error handling: catch LLMUnavailableError and print actionable error: "LLM unavailable. Run 'graphiti health' for diagnostics." Exit EXIT_ERROR.
  </action>
  <verify>
Run: `python -c "from src.cli.commands.summarize import summarize_command; print(summarize_command.__name__)"` should print "summarize_command".
  </verify>
  <done>
summarize_command supports whole-graph (no args) and topic-focused (with arg) summaries. Shows spinner during LLM operation. Outputs rich panel or JSON. Handles LLM unavailability gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement compact command and register both with app</name>
  <files>
    src/cli/commands/compact.py
    src/cli/__init__.py
  </files>
  <action>
Create `src/cli/commands/compact.py`:

Function signature:
```
def compact_command(
    force: Annotated[bool, typer.Option("--force", help="Skip confirmation prompt")] = False,
    global_scope: Annotated[bool, typer.Option("--global", "-g")] = False,
    project_scope: Annotated[bool, typer.Option("--project", "-p")] = False,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
    quiet: Annotated[bool, typer.Option("--quiet", "-q")] = False,
)
```

Implementation:
1. Resolve scope.
2. Load graph stats (stub `_get_graph_stats(scope)` returning mock dict: entity_count, relationship_count, duplicate_count, size_bytes).
3. Show current state to user: "Knowledge graph: {entity_count} entities, {relationship_count} relationships, ~{duplicate_count} potential duplicates".
4. If duplicate_count == 0: print_success("No compaction needed. Graph is clean.") and exit 0.
5. Confirmation per CONTEXT.md: `confirm_action(f"Compact the knowledge graph? This will merge {duplicate_count} duplicate entities.", force=force)`. If declined: print "Cancelled" and exit 0.
6. Spinner: `console.status("Compacting knowledge graph...")` with status updates: "Merging duplicates...", "Rebuilding indexes...", "Finalizing...".
7. Call stub `_compact_graph(scope)` returning mock result dict: merged_count, removed_count, new_entity_count, new_size_bytes.
8. Output:
   - format=="json": print_json(result).
   - Not quiet: print_success with summary: "Compacted: {merged_count} merged, {removed_count} removed. {new_entity_count} entities remaining."
9. Error handling with EXIT_ERROR for runtime failures.

Update `src/cli/__init__.py` to register summarize and compact:
- Import summarize_command from src.cli.commands.summarize
- Import compact_command from src.cli.commands.compact
- `app.command(name="summarize", help="Generate a summary of the knowledge graph")(summarize_command)`
- `app.command(name="compact", help="Compact the knowledge graph by merging duplicates")(compact_command)`
  </action>
  <verify>
Run: `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['--help']); print('summarize' in result.output and 'compact' in result.output)"` should print True.
Run: `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['compact', '--force']); print(result.exit_code)"` should print 0.
  </verify>
  <done>
summarize_command generates whole-graph or topic summaries with LLM. compact_command shows graph stats, prompts for confirmation, compacts with spinner and progress updates. Both registered in app and visible in --help.
  </done>
</task>

</tasks>

<verification>
- `graphiti summarize --help` shows optional topic argument and flags
- `graphiti summarize` produces whole-graph summary output
- `graphiti summarize "architecture"` produces focused summary
- `graphiti compact --help` shows --force and scope flags
- `graphiti compact` shows stats and prompts for confirmation
- `graphiti compact --force` skips confirmation
- Both visible in `graphiti --help`
</verification>

<success_criteria>
1. `graphiti summarize` generates and displays whole-graph summary
2. `graphiti summarize "topic"` generates focused topic summary
3. `graphiti summarize --format json` outputs JSON with summary text
4. `graphiti compact` shows stats and prompts for confirmation
5. `graphiti compact --force` proceeds without prompting
6. `graphiti compact --format json` outputs JSON with compaction results
7. Both commands show spinners during long operations
8. LLM unavailability handled gracefully with actionable error
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-04-SUMMARY.md`
</output>
