---
phase: 04-cli-interface
plan: 08
type: execute
wave: 2
depends_on: ["04-07"]
files_modified:
  - src/cli/commands/add.py
  - src/cli/commands/search.py
  - src/cli/commands/list_cmd.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "graphiti add writes content to the actual Kuzu graph database via Graphiti"
    - "graphiti search queries the real graph and returns actual stored entities/edges"
    - "graphiti list shows real entities from the database, not mock data"
  artifacts:
    - path: "src/cli/commands/add.py"
      provides: "Add command wired to GraphService.add()"
      contains: "from src.graph"
    - path: "src/cli/commands/search.py"
      provides: "Search command wired to GraphService.search()"
      contains: "from src.graph"
    - path: "src/cli/commands/list_cmd.py"
      provides: "List command wired to GraphService.list_entities()"
      contains: "from src.graph"
  key_links:
    - from: "src/cli/commands/add.py"
      to: "src/graph/service.py"
      via: "_add_entity calls GraphService.add()"
      pattern: "run_graph_operation|get_service"
    - from: "src/cli/commands/search.py"
      to: "src/graph/service.py"
      via: "_search_entities calls GraphService.search()"
      pattern: "run_graph_operation|get_service"
    - from: "src/cli/commands/list_cmd.py"
      to: "src/graph/service.py"
      via: "_list_entities calls GraphService.list_entities()"
      pattern: "run_graph_operation|get_service"
---

<objective>
Wire the add, search, and list CLI commands to real graph operations via GraphService, replacing stub functions that return mock data.

Purpose: These are the three most-used commands (write, read, browse). Wiring them closes the primary verification gap: "All core operations work end-to-end from terminal with real data."

Output: Modified add.py, search.py, list_cmd.py with stub functions replaced by GraphService calls
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-interface/04-07-SUMMARY.md
@src/graph/service.py
@src/graph/adapters.py
@src/cli/commands/add.py
@src/cli/commands/search.py
@src/cli/commands/list_cmd.py
@src/cli/utils.py
@src/cli/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire add command to GraphService.add()</name>
  <files>src/cli/commands/add.py</files>
  <action>
Replace the `_add_entity()` stub function in `src/cli/commands/add.py` with a real implementation that calls GraphService.

Changes to make:

1. Add imports at top:
   - `from src.graph import get_service, run_graph_operation`

2. Replace the entire `_add_entity()` function body (lines ~53-100) with:
   - Get service via `get_service()`
   - Call `run_graph_operation(service.add(content=content, scope=scope, project_root=project_root, tags=tags, source=source))`
   - This returns a dict with: name, type, scope, created_at, tags, source, content_length, nodes_created, edges_created
   - Return this dict directly (the existing add_command already handles the result dict format)

3. Update the function docstring to reflect it now performs actual graph operations.

4. Remove the `console.log()` debug lines that said "Would add entity..." - those were only for the stub.

5. Keep the function signature identical so `add_command()` does not need changes.

6. Handle errors: if GraphService raises LLMUnavailableError, catch it and re-raise with a helpful message via print_error. Import `from src.llm import LLMUnavailableError` if not already imported.

7. Keep the `_detect_source()` and `_ensure_project_directory()` helper functions unchanged - they are already production-ready.

The rest of `add_command()` (content resolution, scope resolution, output formatting) stays exactly as-is. Only the stub function body changes.
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && python -c "from src.cli.commands.add import _add_entity; import inspect; src = inspect.getsource(_add_entity); assert 'mock' not in src.lower() and 'stub' not in src.lower(), 'Still contains stub code'; assert 'get_service' in src or 'run_graph_operation' in src, 'Not wired to GraphService'; print('add.py wired OK')"` should confirm no stub/mock references and GraphService integration present.
  </verify>
  <done>_add_entity() calls GraphService.add() which invokes Graphiti.add_episode() to write real content to the Kuzu graph. No mock data returned. Content is sanitized before storage.</done>
</task>

<task type="auto">
  <name>Task 2: Wire search and list commands to GraphService</name>
  <files>src/cli/commands/search.py, src/cli/commands/list_cmd.py</files>
  <action>
Replace stub functions in search.py and list_cmd.py with real GraphService calls.

**search.py changes:**

1. Add imports: `from src.graph import get_service, run_graph_operation`

2. Replace `_search_entities()` body (lines ~15-102) with:
   - Get service via `get_service()`
   - Get project_root from scope resolution (add scope parameter or resolve internally)
   - Call `run_graph_operation(service.search(query=query, scope=scope, project_root=None, exact=exact, limit=limit or 15))`
   - Note: the existing function receives `scope` as a parameter. For project_root, we need to pass it through. Add `project_root: Optional[Path] = None` parameter to _search_entities and pass it from search_command where `scope, project_root = resolve_scope(...)` already provides it.
   - The service returns list[dict] with name, type, snippet, score, created_at, scope, tags - same format the existing code expects
   - Return results directly

3. Update `search_command()` to pass `project_root` (from resolve_scope's second return value) to `_search_entities()`. Currently line 133 does `scope, _ = resolve_scope(...)` - change to `scope, project_root = resolve_scope(...)` and pass project_root.

4. Remove console.log debug lines that said "Searching in..." - those were stub-only.

5. The since/before/type_filter/tags filter parameters: implement what's feasible in the service. For initial wiring, document that date-based and tag filters will be added in future phases. Pass them through but handle gracefully if service doesn't support them yet (the service can ignore unsupported filters and return all results).

6. Keep the function signature compatible with the existing search_command code that calls it.

**list_cmd.py changes:**

1. Add imports: `from src.graph import get_service, run_graph_operation`; `from src.models import GraphScope`

2. Replace `_list_entities()` body (lines ~12-85) with:
   - Accept parameters: `scope: GraphScope, project_root: Optional[Path], limit: Optional[int]`
   - Call `run_graph_operation(service.list_entities(scope=scope, project_root=project_root, limit=limit))`
   - Return results - list of dicts with name, type, created_at, tags, scope, relationship_count

3. Update `list_command()` to pass scope, project_root, and effective_limit to `_list_entities()`:
   - Change `entities = _list_entities()` to `entities = _list_entities(scope, project_root, effective_limit)`
   - The scope and project_root are already resolved on line 104

4. Remove mock data entirely - no more hardcoded entity list.

5. Ensure the returned dict format matches what the table/compact/json formatters expect. The existing code expects: name, type, created_at, tags (as string), scope, relationship_count. The service should return matching keys. If tags come back as list, join with ", " to match existing format.
  </action>
  <verify>
Run: `cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && python -c "
from src.cli.commands.search import _search_entities
from src.cli.commands.list_cmd import _list_entities
import inspect
search_src = inspect.getsource(_search_entities)
list_src = inspect.getsource(_list_entities)
assert 'mock' not in search_src.lower(), 'search still has mock'
assert 'mock' not in list_src.lower(), 'list still has mock'
assert 'get_service' in search_src or 'run_graph_operation' in search_src, 'search not wired'
assert 'get_service' in list_src or 'run_graph_operation' in list_src, 'list not wired'
print('search.py and list_cmd.py wired OK')
"` should confirm both are wired.
  </verify>
  <done>_search_entities() calls GraphService.search() for real semantic/exact graph queries. _list_entities() calls GraphService.list_entities() for real entity listing from Kuzu. No mock data in either function.</done>
</task>

</tasks>

<verification>
1. `grep -c "mock\|stub\|Mock\|Stub" src/cli/commands/add.py src/cli/commands/search.py src/cli/commands/list_cmd.py` shows 0 for all three files
2. `grep -c "get_service\|run_graph_operation\|GraphService" src/cli/commands/add.py src/cli/commands/search.py src/cli/commands/list_cmd.py` shows at least 1 for each file
3. `python -c "from src.cli.commands.add import add_command; from src.cli.commands.search import search_command; from src.cli.commands.list_cmd import list_command; print('All 3 commands import OK')"` succeeds
</verification>

<success_criteria>
- add.py _add_entity() calls GraphService.add() which writes to real Kuzu graph
- search.py _search_entities() calls GraphService.search() which queries real graph
- list_cmd.py _list_entities() calls GraphService.list_entities() which reads real entities
- No mock data or stub references remain in any of the three files
- All three commands still import and work with existing CLI framework (Typer registration)
- Error handling covers LLMUnavailableError with user-friendly messages
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-08-SUMMARY.md`
</output>
