---
phase: 04-cli-interface
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli/commands/config.py
  - src/cli/commands/health.py
  - src/cli/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can run 'graphiti config' to see all configuration settings"
    - "User can run 'graphiti config --set key=value' to modify settings"
    - "User can run 'graphiti health' for quick pass/fail diagnostics"
    - "Health --verbose shows full diagnostic details"
    - "Config validates keys before setting"
    - "Health checks: Ollama connectivity, database status, quota"
    - "--format json works for both commands"
  artifacts:
    - path: "src/cli/commands/config.py"
      provides: "Config command for viewing and modifying settings"
      exports: ["config_command"]
    - path: "src/cli/commands/health.py"
      provides: "Health check command with quick/verbose modes"
      exports: ["health_command"]
  key_links:
    - from: "src/cli/commands/config.py"
      to: "src/llm/config.py"
      via: "Reads and displays LLMConfig settings"
      pattern: "load_config|LLMConfig"
    - from: "src/cli/commands/health.py"
      to: "src/llm/__init__.py"
      via: "get_status() for LLM provider and quota checks"
      pattern: "get_status"
    - from: "src/cli/commands/health.py"
      to: "src/storage/graph_manager.py"
      via: "Checks database connectivity"
      pattern: "GraphManager"
---

<objective>
Implement the config and health CLI commands. Config provides a unified view of all settings with the ability to modify them. Health performs quick diagnostic checks on all system components (Ollama, database, quotas).

Purpose: Config management is essential for users to customize behavior without editing files. Health check is critical for diagnosing connectivity and quota issues. These are the administrative commands that round out the CLI.

Output: Working `graphiti config` and `graphiti health` commands registered with the Typer app.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-cli-interface/04-CONTEXT.md
@.planning/phases/04-cli-interface/04-RESEARCH.md
@.planning/phases/04-cli-interface/04-01-SUMMARY.md
@src/cli/__init__.py
@src/cli/output.py
@src/cli/utils.py
@src/llm/__init__.py
@src/llm/config.py
@src/llm/client.py
@src/llm/quota.py
@src/storage/graph_manager.py
@src/config/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config command</name>
  <files>src/cli/commands/config.py</files>
  <action>
Create `src/cli/commands/config.py`:

Function signature per CONTEXT.md (flags not subcommands):
```
def config_command(
    set_value: Annotated[Optional[str], typer.Option("--set", help="Set config value: key=value")] = None,
    get_key: Annotated[Optional[str], typer.Option("--get", help="Get a specific config value")] = None,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
)
```

IMPORTANT per CONTEXT.md: `graphiti config` (no args) shows all settings. `graphiti config --set key=value` modifies a setting. No subcommands.

Implementation:

1. Define `VALID_CONFIG_KEYS` mapping config key paths to their types and descriptions:
```python
VALID_CONFIG_KEYS = {
    "cloud.endpoint": {"type": str, "desc": "Cloud Ollama endpoint URL"},
    "cloud.api_key": {"type": str, "desc": "Cloud Ollama API key", "sensitive": True},
    "local.endpoint": {"type": str, "desc": "Local Ollama endpoint URL"},
    "local.auto_start": {"type": bool, "desc": "Auto-start local Ollama"},
    "local.models": {"type": list, "desc": "Local model fallback chain"},
    "embeddings.model": {"type": str, "desc": "Embeddings model name"},
    "retry.max_attempts": {"type": int, "desc": "Max retry attempts"},
    "retry.delay_seconds": {"type": int, "desc": "Retry delay in seconds"},
    "timeout.request_seconds": {"type": int, "desc": "Request timeout"},
    "quota.warning_threshold": {"type": float, "desc": "Quota warning threshold (0-1)"},
    "quota.rate_limit_cooldown_seconds": {"type": int, "desc": "Rate limit cooldown"},
    "queue.max_size": {"type": int, "desc": "Request queue max size"},
    "queue.item_ttl_hours": {"type": int, "desc": "Queue item TTL in hours"},
}
```

2. **Show all (no flags):** Load config via `load_config()`. Display as Rich table with columns [Key, Value, Description]. Mask sensitive values (show "***" for api_key if set, "(not set)" if None). Use `dataclasses.asdict()` to iterate config fields, map to their dotted key paths.

3. **Get specific key (`--get`):** Validate key is in VALID_CONFIG_KEYS, print just the value. If format=="json", print_json({key: value}).

4. **Set value (`--set`):** Parse "key=value" string. Validate key is in VALID_CONFIG_KEYS. Validate value type (int, float, bool, str). Load existing TOML file (or create), update the value, write back. Print_success(f"Set {key} = {value}"). TOML file path: `~/.graphiti/llm.toml`.
   - For boolean: accept "true"/"false"/"1"/"0".
   - For list: accept comma-separated values.
   - Write TOML using tomli_w OR manual string formatting (tomli_w is write-only companion to tomllib). Since tomli_w may not be installed, use a simple TOML writer function for the flat config structure.

5. **Validation errors:** If key not in VALID_CONFIG_KEYS, print_error with suggestion: "Unknown config key '{key}'. Run 'graphiti config' to see valid keys." Exit EXIT_BAD_ARGS.
6. If set_value doesn't contain '=': print_error("Invalid format. Use: graphiti config --set key=value"). Exit EXIT_BAD_ARGS.
  </action>
  <verify>
Run: `python -c "from src.cli.commands.config import config_command; print(config_command.__name__)"` should print "config_command".
Run: `python -c "from src.cli.commands.config import VALID_CONFIG_KEYS; print(len(VALID_CONFIG_KEYS) > 5)"` should print True.
  </verify>
  <done>
config_command shows all settings in table format (with masked sensitive values). --get retrieves specific key. --set validates and writes to TOML file. JSON output mode supported. Invalid keys get clear error messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement health command and register config/health with app</name>
  <files>
    src/cli/commands/health.py
    src/cli/__init__.py
  </files>
  <action>
Create `src/cli/commands/health.py`:

Function signature:
```
def health_command(
    verbose: Annotated[bool, typer.Option("--verbose", "-v", help="Show full diagnostic details")] = False,
    format: Annotated[Optional[str], typer.Option("--format", "-f", help="Output format: json")] = None,
)
```

Implementation per CONTEXT.md: quick pass/fail per component by default, --verbose for full diagnostics.

1. Define health check functions:

`_check_ollama_cloud() -> dict`:
- Try to ping cloud endpoint (use httpx.get with short timeout to cloud_endpoint).
- Return {"name": "Cloud Ollama", "status": "ok"/"error", "detail": "Connected"/"Connection failed: {error}"}.
- On error, include suggestion in detail: "Check OLLAMA_API_KEY environment variable".

`_check_ollama_local() -> dict`:
- Try `local_client.list()` to check local Ollama.
- Return {"name": "Local Ollama", "status": "ok"/"error", "detail": "Running, {n} models"/"Not running. Start with: ollama serve"}.
- List available models in detail for verbose mode.

`_check_database(scope, project_root) -> dict`:
- Check if database directory exists and is accessible.
- For global: check `~/.graphiti/global/`.
- For project: check `.graphiti/` in project root (if in project).
- Return {"name": "Database ({scope})", "status": "ok"/"warning"/"error", "detail": "path exists and accessible" or "Not initialized"}.

`_check_quota() -> dict`:
- Get status via `get_status()` from src.llm.
- Return {"name": "Quota", "status": "ok"/"warning"/"error", "detail": usage info}.
- Warning if usage > 80%. Error if usage > 95%.

2. Run all checks. Collect results list.

3. **Quick mode (default):** Display as Rich table with columns [Component, Status, Detail]. Color status: ok=green, warning=yellow, error=red. Use Rich check/cross/warning symbols.

4. **Verbose mode:** Same table plus expanded sections below for each component showing full details: config values, model list, database paths and sizes, quota numbers.

5. **Overall result:** If any check is "error": print overall "Health: FAIL" in red. If any "warning": print "Health: WARNING" in yellow. Else "Health: OK" in green.

6. **format=="json":** print_json({"overall": overall_status, "checks": results_list}).

7. Exit codes: EXIT_SUCCESS if ok/warning, EXIT_ERROR if any error.

Update `src/cli/__init__.py` to register config and health:
- Import config_command from src.cli.commands.config
- Import health_command from src.cli.commands.health
- `app.command(name="config", help="View and modify configuration")(config_command)`
- `app.command(name="health", help="Check system health and diagnostics")(health_command)`

At this point, ALL 9 commands should be registered: add, search, list, show, delete, summarize, compact, config, health.
  </action>
  <verify>
Run: `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['--help']); cmds = ['add','search','list','show','delete','summarize','compact','config','health']; print(all(c in result.output for c in cmds))"` should print True.
Run: `python -c "from typer.testing import CliRunner; from src.cli import app; r = CliRunner(); result = r.invoke(app, ['health']); print(result.exit_code)"` should print 0 or 1 (depending on actual Ollama status).
  </verify>
  <done>
health_command performs quick pass/fail checks (Ollama cloud, Ollama local, database, quota). --verbose shows expanded diagnostics. Config and health registered, completing all 9 CLI commands. `graphiti --help` shows all commands.
  </done>
</task>

</tasks>

<verification>
- `graphiti config` shows all settings in table
- `graphiti config --get cloud.endpoint` shows endpoint value
- `graphiti config --set retry.max_attempts=5` updates config file
- `graphiti config --format json` outputs JSON
- `graphiti health` shows pass/fail for each component
- `graphiti health --verbose` shows expanded details
- `graphiti health --format json` outputs JSON
- All 9 commands visible in `graphiti --help`
</verification>

<success_criteria>
1. `graphiti config` displays all settings with masked sensitive values
2. `graphiti config --get key` retrieves specific setting
3. `graphiti config --set key=value` validates and persists setting to TOML
4. `graphiti health` shows quick pass/fail for cloud Ollama, local Ollama, database, quota
5. `graphiti health --verbose` expands each check with full details
6. Both commands support --format json
7. Invalid config keys show error with suggestion
8. Health exit code is 1 when any component fails
9. All 9 commands registered and visible in --help
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-interface/04-05-SUMMARY.md`
</output>
