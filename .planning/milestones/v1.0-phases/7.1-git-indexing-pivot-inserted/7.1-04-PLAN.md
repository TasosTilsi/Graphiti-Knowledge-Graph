---
phase: 7.1-git-indexing-pivot-inserted
plan: 04
type: execute
wave: 2
depends_on:
  - "7.1-02"
  - "7.1-03"
files_modified:
  - src/cli/commands/index.py
  - src/cli/__init__.py
  - src/cli/commands/hooks.py
autonomous: true
requirements:
  - R8.1
  - R8.2

must_haves:
  truths:
    - "`graphiti index` command runs successfully in a git repository"
    - "`graphiti index --full` resets state and re-processes full history"
    - "`graphiti index --since <date>` processes only commits after the given date"
    - "`graphiti hooks install` installs post-checkout and post-rewrite hooks in addition to existing hook types"
    - "`graphiti hooks install` calls upgrade_postmerge_hook() to migrate old Phase 7 hook installations"
    - "Running `graphiti index` outside a git repository exits with an error message"
    - "`graphiti --help` lists `index` as a registered command"
  artifacts:
    - path: "src/cli/commands/index.py"
      provides: "graphiti index command with --full and --since flags"
      exports: ["index_command"]
    - path: "src/cli/__init__.py"
      provides: "index command registered on the Typer app"
      contains: "index_command"
    - path: "src/cli/commands/hooks.py"
      provides: "Updated hooks install command that deploys all hook types including post-checkout and post-rewrite"
  key_links:
    - from: "src/cli/commands/index.py"
      to: "src/indexer/indexer.py"
      via: "GitIndexer instantiation and run() call"
      pattern: "GitIndexer"
    - from: "src/cli/__init__.py"
      to: "src/cli/commands/index.py"
      via: "app.command(name='index')(index_command) registration"
      pattern: "index_command"
    - from: "src/cli/commands/hooks.py"
      to: "src/hooks/installer.py"
      via: "install_postcheckout_hook, install_postrewrite_hook, upgrade_postmerge_hook calls"
      pattern: "install_postcheckout_hook|install_postrewrite_hook|upgrade_postmerge_hook"
---

<objective>
Wire the indexer into the CLI and complete the hooks install command so all trigger hooks are deployed. This is the final integration plan — users get `graphiti index` as a first-class command and `graphiti hooks install` deploys all indexer hooks automatically.

Purpose: Without the CLI command, the indexer module is unreachable. Without the hooks wiring, the auto-trigger mechanism is incomplete. This plan closes the loop: indexer is callable by users and deployable via hooks.

Output: `graphiti index` command registered and functional. `graphiti hooks install` deploys all five hook types (pre-commit, post-commit, post-merge, post-checkout, post-rewrite).
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/7.1-git-indexing-pivot-inserted/7.1-RESEARCH.md
@.planning/phases/7.1-git-indexing-pivot-inserted/7.1-02-SUMMARY.md
@.planning/phases/7.1-git-indexing-pivot-inserted/7.1-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graphiti index CLI command</name>
  <files>
    src/cli/commands/index.py
  </files>
  <action>
Read src/cli/commands/hooks.py and src/cli/commands/compact.py first to understand the existing command structure, output helpers (console, print_success, print_error, print_warning), and how async operations are handled from CLI commands.

Read src/cli/utils.py to understand resolve_scope() and EXIT_SUCCESS, EXIT_ERROR constants.

Create src/cli/commands/index.py following the exact same patterns.

The command function signature:
```python
def index_command(
    full: Annotated[bool, typer.Option("--full", help="Wipe all git-indexed knowledge and re-index entire history from scratch")] = False,
    since: Annotated[Optional[str], typer.Option("--since", help="Index commits since date (YYYY-MM-DD) or commit SHA")] = None,
    verbose: Annotated[bool, typer.Option("--verbose", "-v", help="Show per-commit progress")] = False,
) -> None:
```

Command body:
1. Resolve scope and project root using the existing `resolve_scope()` or equivalent pattern from other commands. The index command requires a git project root. If root is None or not in a git repo: print_error("Not in a git repository. Cannot index git history.") and raise typer.Exit(EXIT_ERROR).

2. Validate the git repo is accessible: try `git.Repo(root, search_parent_directories=True)` — if GitCommandNotFound or InvalidGitRepositoryError: print_error with actionable message and exit.

3. If `--full`: print_warning("Wiping all git-indexed knowledge. This will re-process the entire git history.")

4. Import GitIndexer from src.indexer and instantiate with project_root=root.

5. Call indexer.reset_full() if full=True.

6. Show progress spinner using console.status() (matching Pattern from hooks.py): "Indexing git history..." during the run.

7. Call `result = indexer.run(since=since, full=False, verbose=verbose)` (full reset already done above if needed).

8. Handle the cooldown case: if result.get("skipped_reason") == "cooldown": print("Index is up to date (ran within the last 5 minutes). Use --full to force re-index.") and return.

9. On success, print a completion summary using print_success():
   - "Indexed {commits_processed} commits, skipped {commits_skipped}"
   - If entities_created > 0: "Extracted knowledge from {commits_processed} commits in {elapsed_seconds:.1f}s"
   - Hint: "Run 'graphiti search <query>' to explore the indexed knowledge."

10. On exception: print_error(f"Indexing failed: {str(e)}") and raise typer.Exit(EXIT_ERROR).

Command docstring: "Index git history into the knowledge graph. Incremental by default — only processes commits not yet indexed. Use --full to wipe and re-index entire history."

Note: Do NOT call asyncio.run() directly in this file — let GitIndexer.run() handle its own async internals (it should use asyncio.run() internally, or the plan-02 executor chose to make it async-aware). Follow how other commands handle operations that may be async — if they use asyncio.run(), do the same here.
  </action>
  <verify>
cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && python -c "
from src.cli.commands.index import index_command
import inspect
sig = inspect.signature(index_command)
params = sig.parameters
assert 'full' in params, 'missing --full flag'
assert 'since' in params, 'missing --since flag'
assert 'verbose' in params, 'missing --verbose flag'
print(f'OK: index_command signature: {sig}')
print('OK: all required parameters present')
"
  </verify>
  <done>src/cli/commands/index.py exists and index_command is importable. The function has --full, --since, and --verbose parameters. The command handles the non-git-repo case with an error exit. No syntax errors.</done>
</task>

<task type="auto">
  <name>Task 2: Register index command in CLI and wire new hooks into hooks install</name>
  <files>
    src/cli/__init__.py
    src/cli/commands/hooks.py
  </files>
  <action>
**src/cli/__init__.py:**
Read the current file (already read in execution context). Add:
- Import: `from src.cli.commands.index import index_command` — add after the existing command imports, following the same alphabetical or logical ordering
- Registration: `app.command(name="index", help="Index git history into the knowledge graph")(index_command)` — add in the registration block near the other command registrations
- Update the comment at the bottom from "All 12 commands registered: ..." to "All 13 commands registered: ..., index"

**src/cli/commands/hooks.py:**
Read the current file fully to understand the `install` subcommand implementation. It currently calls some combination of `install_precommit_hook()`, `install_postcommit_hook()`, `install_postmerge_hook()` from src.hooks.installer.

Make these additions to the `install` subcommand (or the function that orchestrates hook installation):

1. Import the new installer functions at the top of the file (or in the function body if that's the existing pattern):
   `from src.hooks.installer import install_postcheckout_hook, install_postrewrite_hook, upgrade_postmerge_hook`

2. In the install command body, after the existing hook installations, add:
   ```python
   # Upgrade post-merge hook if it's the old Phase 7 journal-based one
   upgrade_postmerge_hook(git_dir)

   # Install new indexer hooks
   install_postcheckout_hook(git_dir)
   install_postrewrite_hook(git_dir)
   ```
   Where `git_dir` is the `.git` directory Path (check how the existing install command resolves it — it may use `git.Repo(search_parent_directories=True).git_dir` or similar).

3. Update the success message to mention that post-checkout and post-rewrite hooks are now installed. Example: "Installed hooks: pre-commit, post-commit, post-merge, post-checkout, post-rewrite"

4. Also update the `status` subcommand (if it exists) to check for post-checkout and post-rewrite hooks in addition to existing ones. Look for how it currently shows hook status and add the two new hook types to the status display.

5. Also update the `uninstall` subcommand (if it exists) to handle post-checkout and post-rewrite — use the same pattern as existing hooks for removal.
  </action>
  <verify>
cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph && \
python -c "
from src.cli import app
# Check index command is registered
cmd_names = [cmd.name for cmd in app.registered_commands]
# Also check typer groups
print('Registered commands:', cmd_names)
assert 'index' in cmd_names, f'index not in commands: {cmd_names}'
print('OK: index command registered in CLI app')
" && \
python -c "
from src.cli.commands.hooks import hooks_app
from src.cli.commands.index import index_command
print('OK: hooks_app and index_command importable')
import inspect
import src.cli.commands.hooks as hooks_mod
src_text = inspect.getsource(hooks_mod)
assert 'install_postcheckout_hook' in src_text or 'postcheckout' in src_text.lower(), 'post-checkout not wired in hooks.py'
assert 'install_postrewrite_hook' in src_text or 'postrewrite' in src_text.lower(), 'post-rewrite not wired in hooks.py'
print('OK: hooks.py references post-checkout and post-rewrite installers')
" && \
graphiti --help 2>&1 | grep -q "index" && echo "OK: graphiti --help shows index command"
  </verify>
  <done>src/cli/__init__.py imports and registers index_command. `graphiti --help` output includes "index". src/cli/commands/hooks.py calls install_postcheckout_hook and install_postrewrite_hook in the install subcommand. upgrade_postmerge_hook is called during install. No import errors.</done>
</task>

</tasks>

<verification>
Full phase 7.1 integration verification (run after all 4 plans complete):
1. `graphiti --help` shows `index` as a registered command
2. `graphiti index --help` shows --full, --since, and --verbose options
3. Inside this project's git repo: `graphiti index` runs without crashing (may fail on LLM unavailability, but CLI plumbing works)
4. `graphiti hooks install` succeeds and shows post-checkout and post-rewrite in the list
5. `ls src/gitops/` does not contain journal.py, lfs.py, checkpoint.py, replay.py, autoheal.py, compact.py
6. `ls src/indexer/` contains __init__.py, indexer.py, state.py, quality_gate.py, extraction.py
7. `ls src/hooks/templates/` contains post-checkout.sh and post-rewrite.sh
8. `git check-ignore .graphiti/index-state.json` exits 0 (confirming gitignore coverage)
</verification>

<success_criteria>
`graphiti index` is a fully registered CLI command accessible from `graphiti --help`. The command delegates to GitIndexer with correct --full, --since, and --verbose flag handling. `graphiti hooks install` deploys all five hook types and upgrades old Phase 7 post-merge hooks automatically. The entire Phase 7.1 implementation is connected: git events trigger hooks which call `graphiti index` which runs GitIndexer which extracts knowledge via add_episode() into Kuzu.
</success_criteria>

<output>
After completion, create `.planning/phases/7.1-git-indexing-pivot-inserted/7.1-04-SUMMARY.md`
</output>
