---
phase: 07-git-integration
plan: 04
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/gitops/hooks.py
  - src/gitops/__init__.py
autonomous: true

must_haves:
  truths:
    - "Pre-commit hook auto-stages new .graphiti/journal/*.json files before commit"
    - "Schema validation catches malformed journal entries before they enter git"
    - "Secret scanning runs on new journal entries only (not full repo) for performance"
    - "Size warnings inform developers when .graphiti/ exceeds 50MB threshold"
    - "GRAPHITI_SKIP=1 environment variable bypasses all pre-commit checks"
  artifacts:
    - path: "src/gitops/hooks.py"
      provides: "Pre-commit validation hooks for journal staging, schema validation, secret scanning, and size checking"
      exports: ["run_precommit_validation", "stage_journal_entries", "validate_journal_schemas", "scan_journal_secrets", "check_graphiti_size"]
  key_links:
    - from: "src/gitops/hooks.py"
      to: "src/gitops/journal.py"
      via: "JournalEntry model for schema validation"
      pattern: "JournalEntry"
    - from: "src/gitops/hooks.py"
      to: "src/security/sanitizer.py"
      via: "sanitize_content for secret scanning"
      pattern: "sanitize_content|ContentSanitizer"
    - from: "src/gitops/hooks.py"
      to: "GitPython"
      via: "git.Repo for staging operations"
      pattern: "repo\\.index\\.add"
---

<objective>
Create pre-commit validation hooks for journal auto-staging, schema validation, secret scanning, and size monitoring.

Purpose: Pre-commit hooks are the "belt" (with .gitattributes as "suspenders") ensuring journal entries are always committed with code changes, validated against the schema, scanned for secrets, and monitored for size. These hooks run fast (delta-only scanning) and can be skipped with GRAPHITI_SKIP=1 for WIP commits.

Output: Pre-commit validation hook functions that can be called from git hooks or CLI.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-git-integration/07-CONTEXT.md
@.planning/phases/07-git-integration/07-RESEARCH.md
@.planning/phases/07-git-integration/07-01-SUMMARY.md
@.planning/phases/07-git-integration/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create journal auto-staging and schema validation hooks</name>
  <files>src/gitops/hooks.py</files>
  <action>
    Create `src/gitops/hooks.py` with:

    **Constants:**
    - `SIZE_WARNING_MB = 50` (configurable warning threshold)
    - `SIZE_STRONG_WARNING_MB = 100` (strongly recommend compact)
    - `SKIP_ENV_VAR = "GRAPHITI_SKIP"` (env var to skip all checks)

    **_is_skip_enabled() -> bool:**
    - Return True if `os.environ.get(SKIP_ENV_VAR) == "1"`
    - This implements the skip mechanism from CONTEXT.md

    **stage_journal_entries(project_root: Path) -> int:**
    - If _is_skip_enabled(), return 0 immediately
    - Use `git.Repo(project_root)` to get repo
    - Find untracked files matching `.graphiti/journal/*.json` pattern from `repo.untracked_files`
    - Also find modified (unstaged) journal files from `repo.index.diff(None)`
    - If any found, stage them via `repo.index.add(paths)`
    - Log count of staged files
    - Return count of staged files
    - On GitPython errors, log warning and return 0 (best-effort, never block commits)

    **validate_journal_schemas(project_root: Path) -> list[str]:**
    - If _is_skip_enabled(), return empty list
    - Find journal files that are staged for commit (in the git index)
    - Use `git.Repo(project_root)` then check `repo.index.diff("HEAD")` for staged .graphiti/journal/*.json files
    - For each staged journal file:
      1. Read the file content
      2. Parse JSON
      3. Validate against JournalEntry Pydantic model using `JournalEntry.model_validate(data)`
      4. If validation fails, append error message to errors list: `f"{filename}: {validation_error}"`
    - Return list of error messages (empty = all valid)
    - Skip files that can't be read (deleted entries in index)

    Use structlog for all logging. Import JournalEntry from src.gitops.journal.
  </action>
  <verify>
    ```bash
    cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph
    python -c "
    from src.gitops.hooks import stage_journal_entries, validate_journal_schemas, _is_skip_enabled
    import os

    # Test skip detection
    assert _is_skip_enabled() == False
    os.environ['GRAPHITI_SKIP'] = '1'
    assert _is_skip_enabled() == True
    del os.environ['GRAPHITI_SKIP']

    # validate_journal_schemas needs a git repo context, test import
    print('stage_journal_entries function exists:', callable(stage_journal_entries))
    print('validate_journal_schemas function exists:', callable(validate_journal_schemas))
    print('Hook functions OK')
    "
    ```
  </verify>
  <done>stage_journal_entries auto-stages untracked journal files. validate_journal_schemas validates staged entries against JournalEntry Pydantic model. GRAPHITI_SKIP=1 bypasses all checks.</done>
</task>

<task type="auto">
  <name>Task 2: Create secret scanning and size check hooks</name>
  <files>src/gitops/hooks.py, src/gitops/__init__.py</files>
  <action>
    Add to `src/gitops/hooks.py`:

    **scan_journal_secrets(project_root: Path) -> list[str]:**
    - If _is_skip_enabled(), return empty list
    - Find staged journal files (same approach as validate_journal_schemas)
    - For each staged journal file:
      1. Read file content
      2. Call `sanitize_content(content)` from `src.security` (already exists from Phase 2)
      3. If result.was_modified (secrets found), append warning: `f"{filename}: secrets detected - {len(result.findings)} finding(s)"`
    - Return list of warnings (empty = clean)
    - This is the "belt" scanning (Phase 2's sanitize_content does the heavy lifting)
    - On import errors (security module issues), log warning and return empty list (best-effort)

    **check_graphiti_size(project_root: Path) -> tuple[float, str | None]:**
    - If _is_skip_enabled(), return (0.0, None)
    - Calculate total size of `.graphiti/` directory (excluding `database/` which is LFS-tracked)
    - Use `sum(f.stat().st_size for f in graphiti_dir.rglob("*") if f.is_file() and "database" not in f.parts)`
    - Convert to MB
    - If > SIZE_STRONG_WARNING_MB: return (size_mb, "STRONG_WARNING: .graphiti/ is {size_mb:.1f}MB. Run 'graphiti compact' to clean up.")
    - If > SIZE_WARNING_MB: return (size_mb, "WARNING: .graphiti/ is {size_mb:.1f}MB. Consider running 'graphiti compact'.")
    - Otherwise: return (size_mb, None)
    - On errors (directory doesn't exist), return (0.0, None)

    **run_precommit_validation(project_root: Path) -> int:**
    - This is the main entry point called from the pre-commit hook
    - If _is_skip_enabled(), print "Graphiti: skipping (GRAPHITI_SKIP=1)" and return 0
    - Step 1: stage_journal_entries(project_root) â€” always first
    - Step 2: errors = validate_journal_schemas(project_root)
    - Step 3: secrets = scan_journal_secrets(project_root)
    - Step 4: size_mb, size_warning = check_graphiti_size(project_root)
    - Print size_warning if present (to stderr)
    - If errors or secrets: print them to stderr, return 1 (block commit)
    - If only size warning: return 0 (warnings don't block)
    - Otherwise: return 0

    Update `src/gitops/__init__.py` to export all hook functions:
    - run_precommit_validation, stage_journal_entries, validate_journal_schemas, scan_journal_secrets, check_graphiti_size
    - Plus all previous exports from plans 01, 02, 03
  </action>
  <verify>
    ```bash
    cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph
    python -c "
    from src.gitops.hooks import scan_journal_secrets, check_graphiti_size, run_precommit_validation
    from pathlib import Path
    import tempfile

    with tempfile.TemporaryDirectory() as tmpdir:
        root = Path(tmpdir)

        # Test size check on empty dir
        size_mb, warning = check_graphiti_size(root)
        assert size_mb == 0.0
        assert warning is None

        # Create some files to test size calculation
        graphiti_dir = root / '.graphiti' / 'journal'
        graphiti_dir.mkdir(parents=True)
        # Create a small file
        (graphiti_dir / 'test.json').write_text('{\"test\": true}')
        size_mb, warning = check_graphiti_size(root)
        assert size_mb > 0
        assert warning is None  # Too small for warning

        print(f'Size: {size_mb:.4f} MB')
        print('Secret scanning and size check OK')

    # Test imports
    from src.gitops import run_precommit_validation
    print('All exports OK')
    "
    ```
  </verify>
  <done>scan_journal_secrets uses Phase 2's sanitize_content on staged journal entries. check_graphiti_size warns at 50MB/100MB thresholds excluding LFS-tracked database. run_precommit_validation orchestrates all checks with appropriate exit codes.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.gitops import run_precommit_validation, stage_journal_entries"` succeeds
2. GRAPHITI_SKIP=1 bypasses all validation hooks
3. Schema validation catches malformed journal entries (missing required fields)
4. Secret scanning leverages existing Phase 2 sanitize_content
5. Size check correctly excludes LFS-tracked database directory
6. run_precommit_validation returns 0 for clean, 1 for errors (never for size warnings)
</verification>

<success_criteria>
- Journal auto-staging stages untracked .graphiti/journal/*.json files
- Schema validation rejects malformed entries before commit
- Secret scanning runs on staged journal entries only (delta)
- Size warnings at 50MB and 100MB thresholds (warn, don't block)
- GRAPHITI_SKIP=1 skips all checks
- run_precommit_validation provides unified entry point
</success_criteria>

<output>
After completion, create `.planning/phases/07-git-integration/07-04-SUMMARY.md`
</output>
