---
phase: 07-git-integration
plan: 05
type: execute
wave: 3
depends_on: ["07-03", "07-04"]
files_modified:
  - src/gitops/autoheal.py
  - src/gitops/compact.py
  - src/cli/commands/compact.py
  - src/hooks/installer.py
  - src/hooks/templates/pre-commit.sh
  - src/hooks/templates/post-merge.sh
  - src/gitops/__init__.py
autonomous: true

must_haves:
  truths:
    - "Post-merge hook triggers incremental journal replay to sync database with merged journal entries"
    - "Pre-commit hook template calls run_precommit_validation for journal staging and validation"
    - "graphiti compact command cleans up old journal entries beyond TTL threshold"
    - "Auto-setup on first graphiti command generates git config files and installs hooks"
    - "Hook templates are installable via existing hook installer infrastructure"
  artifacts:
    - path: "src/gitops/autoheal.py"
      provides: "Post-merge auto-heal and auto-setup logic"
      exports: ["auto_heal", "auto_setup"]
    - path: "src/gitops/compact.py"
      provides: "TTL-based journal cleanup and compaction"
      exports: ["compact_journal", "get_journal_stats"]
    - path: "src/hooks/templates/pre-commit.sh"
      provides: "Pre-commit hook shell template for validation"
    - path: "src/hooks/templates/post-merge.sh"
      provides: "Post-merge hook shell template for auto-heal"
  key_links:
    - from: "src/gitops/autoheal.py"
      to: "src/gitops/replay.py"
      via: "replay_journal for incremental sync"
      pattern: "replay_journal"
    - from: "src/gitops/autoheal.py"
      to: "src/gitops/config.py"
      via: "ensure_git_config for auto-setup"
      pattern: "ensure_git_config"
    - from: "src/gitops/compact.py"
      to: "src/gitops/checkpoint.py"
      via: "checkpoint for safe cleanup boundary"
      pattern: "get_checkpoint"
    - from: "src/hooks/templates/pre-commit.sh"
      to: "src/gitops/hooks.py"
      via: "python -m src.gitops.hooks"
      pattern: "run_precommit_validation"
---

<objective>
Wire auto-heal, compaction, and hook templates to complete git integration.

Purpose: This final plan connects all git integration components: post-merge auto-heal replays new journal entries, pre-commit hook template validates before commits, compact command prunes old entries, and auto-setup bootstraps new clones. The hook templates integrate with the existing Phase 6 hook installer.

Output: Post-merge auto-heal, journal compaction, hook shell templates, and auto-setup for first-run experience.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-git-integration/07-CONTEXT.md
@.planning/phases/07-git-integration/07-RESEARCH.md
@.planning/phases/07-git-integration/07-03-SUMMARY.md
@.planning/phases/07-git-integration/07-04-SUMMARY.md
@.planning/phases/06-automatic-capture/06-02-SUMMARY.md
@src/hooks/installer.py
@src/hooks/templates/post-commit.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auto-heal, auto-setup, and hook templates</name>
  <files>src/gitops/autoheal.py, src/hooks/templates/pre-commit.sh, src/hooks/templates/post-merge.sh, src/hooks/installer.py</files>
  <action>
    **1. Create `src/gitops/autoheal.py`:**

    **auto_heal(project_root: Path, apply_fn: Callable | None = None) -> int:**
    - Log "Auto-healing graph after merge..."
    - Import and call `replay_journal(project_root, apply_fn)` from src.gitops.replay
    - If count > 0: log "Auto-heal complete: replayed N entries"
    - If count == 0: log "No new journal entries to replay"
    - Return count
    - On errors: log error and return 0 (never block merge)

    **auto_setup(project_root: Path) -> dict[str, bool]:**
    - This is called on first `graphiti` command to bootstrap git integration
    - Step 1: Call `ensure_git_config(project_root)` to generate .gitignore and .gitattributes
    - Step 2: Check if pre-commit and post-merge hooks are installed via existing hook system
    - Step 3: If hooks not installed, install them via the existing `src.hooks.installer` module:
      - Install pre-commit hook using same marker-based append pattern as post-commit
      - Install post-merge hook using same pattern
    - Step 4: Check LFS availability and set up tracking if available
    - Return dict with status of each setup step: `{"git_config": bool, "hooks": bool, "lfs": bool}`
    - All steps are best-effort (log warnings, never raise)
    - Use structlog for logging

    **2. Create `src/hooks/templates/pre-commit.sh`:**
    ```bash
    #!/bin/bash
    # Graphiti Knowledge Graph - Pre-commit validation hook
    # Auto-stages journal entries, validates schemas, scans for secrets

    # Skip if GRAPHITI_SKIP is set
    if [ "$GRAPHITI_SKIP" = "1" ]; then
        exit 0
    fi

    # Check if graphiti is available
    if ! command -v graphiti &> /dev/null; then
        exit 0
    fi

    # Check if hooks are enabled
    ENABLED=$(graphiti config get hooks.enabled 2>/dev/null)
    if [ "$ENABLED" = "false" ]; then
        exit 0
    fi

    # Run pre-commit validation
    python -m src.gitops.hooks precommit 2>&1
    exit $?
    ```

    Wait - the module entry point won't work as `python -m src.gitops.hooks`. Instead, use graphiti CLI or direct python invocation. Better approach: add a `__main__` block to `src/gitops/hooks.py` that calls `run_precommit_validation` when run as a script, OR use the graphiti CLI entry point.

    Actually, the simplest approach matching the existing post-commit.sh pattern: use `graphiti git validate` CLI command. But we haven't created that CLI command yet. Let's use a direct Python call via the installed package:

    ```bash
    #!/bin/bash
    # Graphiti Knowledge Graph - Pre-commit validation hook

    if [ "$GRAPHITI_SKIP" = "1" ]; then
        exit 0
    fi

    if ! command -v graphiti &> /dev/null; then
        exit 0
    fi

    ENABLED=$(graphiti config get hooks.enabled 2>/dev/null)
    if [ "$ENABLED" = "false" ]; then
        exit 0
    fi

    # Run pre-commit validation (auto-stage, schema check, secret scan, size check)
    python -c "
    from pathlib import Path
    from src.gitops.hooks import run_precommit_validation
    import sys
    sys.exit(run_precommit_validation(Path('.')))
    " 2>&1
    exit $?
    ```

    **3. Create `src/hooks/templates/post-merge.sh`:**
    ```bash
    #!/bin/bash
    # Graphiti Knowledge Graph - Post-merge auto-heal hook
    # Replays new journal entries after merge to sync local database

    if [ "$GRAPHITI_SKIP" = "1" ]; then
        exit 0
    fi

    if ! command -v graphiti &> /dev/null; then
        exit 0
    fi

    ENABLED=$(graphiti config get hooks.enabled 2>/dev/null)
    if [ "$ENABLED" = "false" ]; then
        exit 0
    fi

    # Run auto-heal (incremental journal replay)
    python -c "
    from pathlib import Path
    from src.gitops.autoheal import auto_heal
    auto_heal(Path('.'))
    " 2>&1

    # Always exit 0 - never block merge
    exit 0
    ```

    **4. Update `src/hooks/installer.py`:**
    - Add `install_precommit_hook(project_root: Path) -> bool` function following the same marker-based append pattern as `install_git_hook` but for the pre-commit hook type
    - Add `install_postmerge_hook(project_root: Path) -> bool` function for post-merge hook
    - Both use the GRAPHITI_HOOK_START/GRAPHITI_HOOK_END markers (same pattern as existing post-commit)
    - Both read their respective templates from src/hooks/templates/
    - Add corresponding `uninstall_precommit_hook` and `uninstall_postmerge_hook`
    - Add corresponding `is_precommit_hook_installed` and `is_postmerge_hook_installed`
    - Generalize the existing install/uninstall/is_installed pattern if possible (DRY) by extracting a common `_install_hook(hook_name, template_path, project_root)` helper
  </action>
  <verify>
    ```bash
    cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph
    python -c "
    from src.gitops.autoheal import auto_heal, auto_setup
    from pathlib import Path
    import tempfile

    with tempfile.TemporaryDirectory() as tmpdir:
        root = Path(tmpdir)
        # Create minimal .graphiti structure
        (root / '.graphiti' / 'journal').mkdir(parents=True)
        (root / '.git' / 'hooks').mkdir(parents=True)

        # Test auto_heal with no entries
        count = auto_heal(root)
        assert count == 0

        print('Auto-heal OK')

    # Verify templates exist
    from pathlib import Path
    templates = Path('src/hooks/templates')
    assert (templates / 'pre-commit.sh').exists(), 'pre-commit.sh missing'
    assert (templates / 'post-merge.sh').exists(), 'post-merge.sh missing'
    print('Templates OK')

    # Verify installer has new functions
    from src.hooks.installer import install_precommit_hook, install_postmerge_hook
    print('Installer extended OK')
    "
    ```
  </verify>
  <done>Post-merge auto-heal replays new journal entries. Pre-commit hook template validates journal entries before commit. Hook installer extended with pre-commit and post-merge hook support using existing marker-based pattern. Auto-setup bootstraps git config and hooks on first run.</done>
</task>

<task type="auto">
  <name>Task 2: Create journal compaction with TTL cleanup</name>
  <files>src/gitops/compact.py, src/cli/commands/compact.py, src/gitops/__init__.py</files>
  <action>
    **1. Create `src/gitops/compact.py`:**

    **Constants:**
    - `DEFAULT_TTL_DAYS = 30` (journal entries older than this and before checkpoint are deletable)
    - `SAFETY_BUFFER_DAYS = 7` (never delete entries newer than checkpoint + buffer)

    **get_journal_stats(project_root: Path) -> dict:**
    - Count total journal entries
    - Calculate total journal size in bytes
    - Get oldest and newest entry timestamps (from filenames)
    - Get checkpoint position
    - Count entries before checkpoint (eligible for cleanup)
    - Count entries after checkpoint (active)
    - Return dict: `{"total_entries": int, "total_size_bytes": int, "oldest": str|None, "newest": str|None, "before_checkpoint": int, "after_checkpoint": int}`

    **compact_journal(project_root: Path, ttl_days: int = DEFAULT_TTL_DAYS, dry_run: bool = False) -> dict:**
    - Get checkpoint. If no checkpoint, return `{"deleted": 0, "reason": "No checkpoint set. Run replay first."}` (can't safely delete without checkpoint)
    - Calculate cutoff date: `datetime.now(timezone.utc) - timedelta(days=ttl_days)`
    - For each journal entry (sorted):
      - Stop at checkpoint entry (never delete at or after checkpoint)
      - Parse the entry's timestamp from JSON content
      - If entry timestamp < cutoff_date:
        - If dry_run: add to "would_delete" list
        - Else: delete the file
    - Apply safety buffer: never delete entries whose timestamp is within SAFETY_BUFFER_DAYS of now (even if before checkpoint and older than TTL - extra safety)
    - Return dict: `{"deleted": int, "bytes_freed": int, "dry_run": bool, "remaining": int}`
    - Log all deletions via structlog

    **2. Update `src/cli/commands/compact.py`:**
    - The existing compact command does entity deduplication. Add journal compaction as an additional operation:
    - After existing graph compaction, add a section that calls `compact_journal(project_root, dry_run=dry_run_flag)` if `--journal` flag is passed (or always include journal stats)
    - Add `--journal` flag to compact command: when set, also run journal compaction
    - Add `--ttl-days` option (default 30) for journal TTL
    - Add `--dry-run` flag to preview what would be deleted
    - Display journal stats: total entries, size, entries to be cleaned
    - Use Rich table formatting consistent with existing CLI output

    **3. Update `src/gitops/__init__.py`:**
    - Export auto_heal, auto_setup from autoheal module
    - Export compact_journal, get_journal_stats from compact module
    - Complete final __init__.py with all gitops exports organized by submodule
  </action>
  <verify>
    ```bash
    cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph
    python -c "
    from src.gitops.compact import compact_journal, get_journal_stats, DEFAULT_TTL_DAYS
    from src.gitops.journal import create_journal_entry, JournalOperation
    from src.gitops.checkpoint import set_checkpoint
    from pathlib import Path
    import tempfile, time

    with tempfile.TemporaryDirectory() as tmpdir:
        root = Path(tmpdir)

        # Create journal entries
        e1 = create_journal_entry(JournalOperation.ADD_ENTITY, {'name': 'Old'}, project_root=root)
        time.sleep(0.01)
        e2 = create_journal_entry(JournalOperation.ADD_ENTITY, {'name': 'Middle'}, project_root=root)
        time.sleep(0.01)
        e3 = create_journal_entry(JournalOperation.ADD_ENTITY, {'name': 'New'}, project_root=root)

        # Get stats
        stats = get_journal_stats(root)
        assert stats['total_entries'] == 3
        print(f'Stats: {stats}')

        # Can't compact without checkpoint
        result = compact_journal(root)
        assert result['deleted'] == 0
        assert 'No checkpoint' in result.get('reason', '')

        # Set checkpoint to last entry
        set_checkpoint(root, e3.name)

        # Try dry run (entries are too new for TTL, so none deleted)
        result = compact_journal(root, ttl_days=0, dry_run=True)
        print(f'Dry run: {result}')

        # Normal compact with 0 TTL should delete entries before checkpoint
        # But safety buffer prevents deletion of recent entries
        result = compact_journal(root, ttl_days=0)
        print(f'Compact result: {result}')

        print('Compact OK')
    "
    ```
  </verify>
  <done>compact_journal removes old journal entries respecting TTL, checkpoint boundary, and safety buffer. get_journal_stats provides overview of journal state. CLI compact command extended with --journal flag for journal cleanup with Rich-formatted output.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.gitops import auto_heal, auto_setup, compact_journal"` succeeds
2. Post-merge auto-heal calls replay_journal and returns entry count
3. Pre-commit hook template checks GRAPHITI_SKIP and hooks.enabled before running
4. compact_journal never deletes entries at or after checkpoint
5. compact_journal respects both TTL and safety buffer
6. Hook templates are installable via extended installer
7. Auto-setup generates git config and installs hooks
</verification>

<success_criteria>
- Post-merge hook triggers incremental journal replay
- Pre-commit hook auto-stages, validates, scans, and checks size
- Hook templates use existing marker-based installer pattern
- Journal compaction cleans entries older than TTL and before checkpoint
- Auto-setup bootstraps complete git integration on first run
- CLI compact command includes journal cleanup option
- All gitops module exports organized and complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-git-integration/07-05-SUMMARY.md`
</output>
