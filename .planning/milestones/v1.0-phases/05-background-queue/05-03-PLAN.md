---
phase: 05-background-queue
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/cli/commands/queue_cmd.py
  - src/cli/__init__.py
autonomous: true

must_haves:
  truths:
    - "graphiti queue status displays pending/dead-letter counts with ok/warning/error health indicator"
    - "graphiti queue process manually processes pending jobs via CLI fallback"
    - "graphiti queue retry moves dead letter job back to main queue for reprocessing"
    - "Queue command group registered and accessible via graphiti queue --help"
  artifacts:
    - path: "src/cli/commands/queue_cmd.py"
      provides: "CLI queue subcommands: status, process, retry"
      contains: "queue_app"
    - path: "src/cli/__init__.py"
      provides: "Queue command group registration"
      contains: "queue"
  key_links:
    - from: "src/cli/commands/queue_cmd.py"
      to: "src/queue"
      via: "CLI commands call public API functions"
      pattern: "from src\\.queue import"
    - from: "src/cli/__init__.py"
      to: "src/cli/commands/queue_cmd.py"
      via: "Typer app.add_typer() for command group"
      pattern: "add_typer.*queue"
---

<objective>
Build the CLI interface for queue inspection, manual processing, and dead letter management, then register it in the main app.

Purpose: Provide user-facing queue management via `graphiti queue` command group. Enables queue inspection (status), manual processing fallback when MCP isn't running (process), and dead letter job recovery (retry). Follows same UX patterns as `graphiti health` (ok/warning/error thresholds per user decision).
Output: Complete CLI queue commands integrated into the main Typer app.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-background-queue/05-RESEARCH.md
@.planning/phases/05-background-queue/05-CONTEXT.md
@.planning/phases/05-background-queue/05-01-SUMMARY.md
@.planning/phases/05-background-queue/05-02-SUMMARY.md
@src/cli/__init__.py
@src/cli/commands/health.py
@src/cli/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create queue CLI command group with status, process, and retry subcommands</name>
  <files>src/cli/commands/queue_cmd.py</files>
  <action>
Create src/cli/commands/queue_cmd.py implementing the queue command group. Follow the established pattern from src/cli/commands/health.py for output formatting and status indicators.

**queue_app = typer.Typer()** — Create a Typer sub-app for the queue command group.

**status subcommand** (`@queue_app.command(name="status")`):

`def status_command(format: str = typer.Option("text", "--format", "-f", help="Output format: text or json")):`

1. Call `from src.queue import get_status` to get queue state
2. Determine health indicator (same pattern as `graphiti health` per user decision):
   - Green "ok": pending < 80% of max_size
   - Yellow "warning": pending >= 80% of max_size (message: "Queue nearly full")
   - Red "error": pending >= 100% of max_size (message: "Queue at or over capacity")
3. If format == "json": output JSON dict with all stats and exit
4. If format == "text": use Rich Table (title "Queue Status") with columns:
   - Status: color-coded health indicator
   - Pending Jobs: count
   - Capacity: "N/M" format (e.g., "45/100")
   - Dead Letter: count of failed jobs in dead letter table
   - Worker: "running" or "stopped"
   - Message: health message

If dead letter count > 0, add a note: "Run 'graphiti queue retry <job_id>' to reprocess failed jobs"

**process subcommand** (`@queue_app.command(name="process")`):

`def process_command():`

1. Call `from src.queue import process_queue`
2. Display "Processing queue..." message
3. Call process_queue() — this starts worker and processes until empty
4. Display results: "Processed N jobs (M failures)" using Rich console
5. This is the CLI fallback for manual processing when MCP isn't running (per user decision)

**retry subcommand** (`@queue_app.command(name="retry")`):

`def retry_command(job_id: str = typer.Argument(..., help="Dead letter job ID to retry, or 'all' to retry all")):`

1. Call `from src.queue import get_queue`
2. If job_id == "all":
   - Get all dead letter jobs via get_queue().get_dead_letter_jobs()
   - For each: call get_queue().retry_dead_letter(job.id)
   - Display count of requeued jobs
3. Else:
   - Call get_queue().retry_dead_letter(job_id)
   - If True: display "Job {job_id} moved back to queue for retry"
   - If False: display error "Job {job_id} not found in dead letter queue"

**Output patterns:**
- Use `from src.cli.output import console, err_console, format_output, print_error` for consistent output
- Use Rich Table for status display (same as health command)
- JSON format support for programmatic use
- Color-coded health indicators: [green]ok[/green], [yellow]warning[/yellow], [red]error[/red]
  </action>
  <verify>
Run: `python -m src.cli --help` and verify "queue" appears in command list.
Run: `python -m src.cli queue --help` and verify status, process, retry subcommands listed.
Run: `python -m src.cli queue status` and verify it displays queue stats table.
Run: `python -m src.cli queue status --format json` and verify JSON output.
  </verify>
  <done>Queue CLI command group provides status (with health indicators), process (manual fallback), and retry (dead letter recovery). Output follows established health command patterns with Rich tables, JSON format support, and color-coded status indicators.</done>
</task>

<task type="auto">
  <name>Task 2: Register queue command group and verify integration</name>
  <files>src/cli/__init__.py</files>
  <action>
Update src/cli/__init__.py to register the queue command group.

1. Add import: `from src.cli.commands.queue_cmd import queue_app`

2. Register as command group using Typer's add_typer:
   ```python
   app.add_typer(queue_app, name="queue", help="Manage the background processing queue")
   ```

   Place this after the existing individual command registrations (after the health command registration block).

3. Update the comment at the bottom to reflect the new count:
   ```python
   # All 10 commands registered: add, search, list, show, delete, summarize, compact, config, health, queue (group)
   ```

4. Verify the full command tree works:
   - `graphiti queue status` — shows queue health
   - `graphiti queue process` — manual processing
   - `graphiti queue retry <id>` — dead letter recovery
   - `graphiti --help` — shows queue in command list

**Note on --async flag:** The `--async` flag for existing commands (add, etc.) that enables explicit async queueing will be added in Phase 6 when actual capture logic is implemented. Phase 5 builds the queue infrastructure; Phase 6 adds the capture-and-queue integration. This keeps Phase 5 focused on the queue system itself per the phase boundary: "This phase builds the processing infrastructure -- actual capture logic (hooks, conversations) belongs in Phase 6."
  </action>
  <verify>
Run these commands in sequence:
1. `python -m src.cli --help` — verify "queue" appears with help text "Manage the background processing queue"
2. `python -m src.cli queue --help` — verify status, process, retry subcommands
3. `python -m src.cli queue status` — verify table output with queue stats
4. `python -m src.cli queue status --format json` — verify JSON output

All existing commands (add, search, list, show, delete, summarize, compact, config, health) must still work unchanged.
  </verify>
  <done>Queue command group registered in main CLI app. All 10 command groups accessible. Existing commands unaffected. Queue status, process, and retry commands functional through CLI entry point.</done>
</task>

</tasks>

<verification>
1. `graphiti queue status` displays Rich table with pending/dead-letter/worker status
2. `graphiti queue status --format json` outputs valid JSON with health level
3. `graphiti queue process` attempts to process pending jobs (success with empty queue)
4. `graphiti queue retry nonexistent-id` shows "not found" error message
5. Full integration: enqueue a job programmatically, verify it appears in `graphiti queue status`
6. All existing CLI commands still work (regression check: `graphiti health`, `graphiti --help`)
</verification>

<success_criteria>
- graphiti queue status shows correct health indicator (ok/warning/error at 80%/100% thresholds)
- graphiti queue process provides CLI fallback for manual processing
- graphiti queue retry recovers dead letter jobs
- JSON format support for programmatic use
- Command registered in main app without breaking existing commands
- UX consistent with graphiti health command patterns
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-queue/05-03-SUMMARY.md`
</output>
