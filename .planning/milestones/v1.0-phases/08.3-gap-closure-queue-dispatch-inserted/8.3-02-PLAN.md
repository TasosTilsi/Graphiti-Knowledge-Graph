---
phase: 8.3-gap-closure-queue-dispatch-inserted
plan: 02
type: execute
wave: 2
depends_on:
  - 8.3-01
files_modified:
  - tests/test_queue_worker_dispatch.py
autonomous: true
requirements:
  - R4.2
  - R4.3
gap_closure: true

must_haves:
  truths:
    - "capture_git_commits jobs are processed by the worker without entering the dead letter queue"
    - "The worker correctly calls process_pending_commits() when job_type matches"
    - "Malformed capture_git_commits jobs (missing pending_file) raise RuntimeError and retry"
    - "Other job types still execute via the generic CLI subprocess path"
    - "Dead letter queue is empty after processing a capture_git_commits job with a valid pending file"
  artifacts:
    - path: "tests/test_queue_worker_dispatch.py"
      provides: "Unit tests for _replay_command dispatch logic"
      exports: ["TestCaptureGitCommitsDispatch", "TestGenericCommandReplay"]
  key_links:
    - from: "tests/test_queue_worker_dispatch.py"
      to: "src/queue/worker.py:_handle_capture_git_commits"
      via: "unittest.mock.patch of process_pending_commits"
      pattern: "mock.*process_pending_commits"
    - from: "tests/test_queue_worker_dispatch.py"
      to: "src/queue/worker.py:_replay_command"
      via: "direct call on BackgroundWorker instance"
      pattern: "_replay_command.*capture_git_commits"
---

<objective>
Create `tests/test_queue_worker_dispatch.py` with focused unit tests that verify the
dispatch fix introduced in Plan 01, plus an integration smoke test that exercises
Flow 3 end-to-end using a real pending file.

Purpose: Confirms R4.2 (git capture queue path works) and R4.3 (background processing
routes correctly) without requiring a running LLM or live Kuzu DB. The integration test
uses `unittest.mock` to patch the LLM/storage layer so the full queue → worker →
`process_pending_commits()` path executes in CI.

Output: `tests/test_queue_worker_dispatch.py` with three test classes.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/8.3-gap-closure-queue-dispatch-inserted/8.3-01-SUMMARY.md
@src/queue/worker.py
@src/capture/git_worker.py
@src/queue/storage.py
@src/queue/__init__.py
@tests/test_llm_queue.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write unit tests for _replay_command dispatch and _handle_capture_git_commits</name>
  <files>tests/test_queue_worker_dispatch.py</files>
  <action>
Create `tests/test_queue_worker_dispatch.py` with the following test classes. Follow
the project's existing test style from `tests/test_llm_queue.py`: pytest fixtures,
class-based grouping, descriptive method names, `tmp_path` for isolation.

```python
"""Tests for BackgroundWorker job-type dispatch.

Verifies that _replay_command() correctly dispatches capture_git_commits jobs
to _handle_capture_git_commits() instead of the generic CLI subprocess path.

Bug context (Phase 8.3 gap closure):
    git_worker.enqueue_git_processing() creates jobs with:
        job_type="capture_git_commits", payload={"pending_file": "/path/..."}
    Previously _replay_command() read payload.get('command', '') → "" which
    caused subprocess failure and moved every git capture job to dead letter.

Fix: _replay_command() now checks job_type first and dispatches to
_handle_capture_git_commits() which calls process_pending_commits() directly.
"""

import asyncio
import tempfile
from pathlib import Path
from unittest.mock import patch, AsyncMock, MagicMock
import pytest

from src.queue.storage import JobQueue
from src.queue.worker import BackgroundWorker


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _make_job(job_type: str, payload: dict, job_id: str = "test-job-001") -> dict:
    """Build a minimal job dict matching what JobQueue.get_batch() returns."""
    return {
        "id": job_id,
        "job_type": job_type,
        "payload": payload,
        "parallel": False,
        "attempts": 0,
        "created_at": 0.0,
        "status": "pending",
        "last_error": None,
    }


@pytest.fixture
def worker(tmp_path):
    """BackgroundWorker with isolated tmp queue."""
    queue = JobQueue(db_path=tmp_path / "queue")
    return BackgroundWorker(queue)


# ---------------------------------------------------------------------------
# Class 1: dispatch routing
# ---------------------------------------------------------------------------

class TestCaptureGitCommitsDispatch:
    """_replay_command() routes capture_git_commits to _handle_capture_git_commits."""

    def test_dispatch_calls_handler_not_subprocess(self, worker):
        """capture_git_commits jobs call the handler, never subprocess.run."""
        job = _make_job(
            job_type="capture_git_commits",
            payload={"pending_file": "/tmp/fake_pending"},
        )

        with patch.object(worker, "_handle_capture_git_commits", return_value=True) as mock_handler, \
             patch("subprocess.run") as mock_subprocess:
            worker._replay_command(job)

        mock_handler.assert_called_once_with(job)
        mock_subprocess.assert_not_called()

    def test_handler_failure_raises_runtime_error(self, worker):
        """Handler returning False causes RuntimeError (job will retry)."""
        job = _make_job(
            job_type="capture_git_commits",
            payload={},  # Missing pending_file → handler returns False
        )

        with patch.object(worker, "_handle_capture_git_commits", return_value=False):
            with pytest.raises(RuntimeError, match="capture_git_commits handler failed"):
                worker._replay_command(job)

    def test_generic_job_uses_subprocess(self, worker):
        """Non-capture job types still go through subprocess.run."""
        job = _make_job(
            job_type="add_knowledge",
            payload={"command": "add", "args": ["hello"], "kwargs": {}},
        )

        mock_result = MagicMock()
        mock_result.returncode = 0

        with patch("subprocess.run", return_value=mock_result) as mock_subprocess, \
             patch.object(worker, "_handle_capture_git_commits") as mock_handler:
            worker._replay_command(job)

        mock_subprocess.assert_called_once()
        mock_handler.assert_not_called()
        # Verify the subprocess was called with the right command structure
        call_args = mock_subprocess.call_args[0][0]
        assert call_args[0] == "graphiti"
        assert call_args[1] == "add"


# ---------------------------------------------------------------------------
# Class 2: _handle_capture_git_commits unit tests
# ---------------------------------------------------------------------------

class TestHandleCaptureGitCommits:
    """Unit tests for _handle_capture_git_commits() method."""

    def test_missing_pending_file_key_returns_false(self, worker):
        """Payload without 'pending_file' returns False (malformed job)."""
        job = _make_job(
            job_type="capture_git_commits",
            payload={},  # No pending_file key
        )
        result = worker._handle_capture_git_commits(job)
        assert result is False

    def test_empty_pending_file_value_returns_false(self, worker):
        """Payload with pending_file=None or '' returns False."""
        job = _make_job(
            job_type="capture_git_commits",
            payload={"pending_file": ""},
        )
        result = worker._handle_capture_git_commits(job)
        assert result is False

    def test_valid_pending_file_calls_process_pending_commits(self, worker, tmp_path):
        """Valid pending_file triggers asyncio.run(process_pending_commits(...))."""
        pending_file = tmp_path / "pending_commits"
        # Write a fake commit hash so process_pending_commits has something to read
        pending_file.write_text("abc1234567890\n")

        job = _make_job(
            job_type="capture_git_commits",
            payload={"pending_file": str(pending_file)},
        )

        # Patch process_pending_commits to avoid real LLM/git calls
        with patch(
            "src.capture.git_worker.process_pending_commits",
            new_callable=AsyncMock,
            return_value=[],
        ) as mock_ppc:
            result = worker._handle_capture_git_commits(job)

        assert result is True
        mock_ppc.assert_called_once()
        # Verify it was called with the correct pending_file Path
        call_kwargs = mock_ppc.call_args.kwargs
        assert "pending_file" in call_kwargs
        assert str(call_kwargs["pending_file"]) == str(pending_file)

    def test_nonexistent_pending_file_still_returns_true(self, worker):
        """process_pending_commits handles missing file gracefully (returns []).

        The handler should return True because process_pending_commits() does not
        raise on a missing file — it returns an empty list. The handler's job is
        only to dispatch; it should not pre-validate file existence.
        """
        job = _make_job(
            job_type="capture_git_commits",
            payload={"pending_file": "/tmp/definitely_does_not_exist_8a3b2c"},
        )

        with patch(
            "src.capture.git_worker.process_pending_commits",
            new_callable=AsyncMock,
            return_value=[],
        ) as mock_ppc:
            result = worker._handle_capture_git_commits(job)

        assert result is True
        mock_ppc.assert_called_once()


# ---------------------------------------------------------------------------
# Class 3: Integration smoke test (queue → worker → process_pending_commits)
# ---------------------------------------------------------------------------

class TestFlow3Integration:
    """End-to-end smoke test for Flow 3: enqueue → worker → process_pending_commits.

    Uses a real JobQueue and BackgroundWorker. Patches process_pending_commits
    to avoid LLM/Kuzu dependencies.
    """

    def test_enqueued_capture_job_does_not_land_in_dead_letter(self, tmp_path):
        """Enqueued capture_git_commits job is processed, not dead-lettered.

        This is the regression test for the Phase 8.3 bug:
        Before fix: job_type='capture_git_commits' → _replay_command reads
                    payload.get('command', '') → '' → subprocess(['graphiti', ''])
                    → non-zero exit → RuntimeError → 3 retries → dead letter.
        After fix:  dispatches to _handle_capture_git_commits → asyncio.run(
                    process_pending_commits()) → success → ack → dead_letter=0.
        """
        # Create a pending commits file with one fake hash
        pending_file = tmp_path / "pending_commits"
        pending_file.write_text("deadbeef01234567\n")

        queue = JobQueue(db_path=tmp_path / "queue")
        worker = BackgroundWorker(queue, max_workers=1)

        # Enqueue the job exactly as git_worker.enqueue_git_processing() does
        queue.enqueue(
            job_type="capture_git_commits",
            payload={"pending_file": str(pending_file)},
            parallel=False,
        )

        assert queue.get_pending_count() == 1

        # Patch process_pending_commits to avoid real git/LLM calls
        with patch(
            "src.capture.git_worker.process_pending_commits",
            new_callable=AsyncMock,
            return_value=[],
        ):
            # Process the single job (one iteration of the worker loop)
            batch = queue.get_batch(max_items=1)
            assert len(batch) == 1
            worker._execute_with_retry(batch[0])

        # Job should be acknowledged (pending=0) and NOT in dead letter
        assert queue.get_pending_count() == 0
        stats = queue.get_stats()
        assert stats.dead_letter == 0, (
            f"Job landed in dead letter queue. "
            f"dead_letter={stats.dead_letter}. "
            "Dispatch fix may not be applied correctly."
        )
```

The test file must be placed at `tests/test_queue_worker_dispatch.py`.

**Import note:** The patch target for `process_pending_commits` must be
`"src.capture.git_worker.process_pending_commits"` because `_handle_capture_git_commits`
imports it as `from src.capture.git_worker import process_pending_commits` — patch where
it is used, not where it is defined.

**Do NOT use `monkeypatch.setattr`** for async functions — `AsyncMock` is required because
`process_pending_commits` is a coroutine function. Using `MagicMock` would cause
`asyncio.run()` to raise `TypeError: a coroutine was expected`.
  </action>
  <verify>
Run the test suite from the project root:

```bash
.venv/bin/pytest tests/test_queue_worker_dispatch.py -v
```

Expected output:
```
tests/test_queue_worker_dispatch.py::TestCaptureGitCommitsDispatch::test_dispatch_calls_handler_not_subprocess PASSED
tests/test_queue_worker_dispatch.py::TestCaptureGitCommitsDispatch::test_handler_failure_raises_runtime_error PASSED
tests/test_queue_worker_dispatch.py::TestCaptureGitCommitsDispatch::test_generic_job_uses_subprocess PASSED
tests/test_queue_worker_dispatch.py::TestHandleCaptureGitCommits::test_missing_pending_file_key_returns_false PASSED
tests/test_queue_worker_dispatch.py::TestHandleCaptureGitCommits::test_empty_pending_file_value_returns_false PASSED
tests/test_queue_worker_dispatch.py::TestHandleCaptureGitCommits::test_valid_pending_file_calls_process_pending_commits PASSED
tests/test_queue_worker_dispatch.py::TestHandleCaptureGitCommits::test_nonexistent_pending_file_still_returns_true PASSED
tests/test_queue_worker_dispatch.py::TestFlow3Integration::test_enqueued_capture_job_does_not_land_in_dead_letter PASSED
8 passed in X.XXs
```

All 8 tests must pass. No xfail, no skip, no error.

Also confirm existing tests still pass (no regressions):
```bash
.venv/bin/pytest tests/ -v --ignore=tests/test_llm_integration.py -q
```
(Skip test_llm_integration.py as it requires a live Ollama instance.)
  </verify>
  <done>
- `tests/test_queue_worker_dispatch.py` exists with 8 tests across 3 classes
- All 8 tests pass with `.venv/bin/pytest tests/test_queue_worker_dispatch.py -v`
- `TestFlow3Integration::test_enqueued_capture_job_does_not_land_in_dead_letter` passes,
  confirming dead_letter=0 after processing a capture_git_commits job
- No regressions in the existing test suite
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `pytest tests/test_queue_worker_dispatch.py -v` — 8 tests pass, 0 fail
2. `pytest tests/ -q --ignore=tests/test_llm_integration.py` — no new failures vs baseline
3. The integration test `test_enqueued_capture_job_does_not_land_in_dead_letter` explicitly
   asserts `stats.dead_letter == 0` — this is the regression guard for the Phase 8.3 bug
4. `pytest tests/test_queue_worker_dispatch.py -v -k "flow3"` shows the integration test
   passing on its own

**Flow 3 trace (verified by tests):**
```
post-commit hook
  → git_worker.enqueue_git_processing()
    → queue.enqueue(job_type="capture_git_commits", payload={"pending_file": "..."})
      → BackgroundWorker._execute_with_retry()
        → BackgroundWorker._replay_command()            [checks job_type first]
          → BackgroundWorker._handle_capture_git_commits()
            → asyncio.run(process_pending_commits(pending_file=...))
              → security filter → LLM → Kuzu DB
        → queue.ack()                                   [success, not dead letter]
```
</verification>

<success_criteria>
- 8 new tests in `tests/test_queue_worker_dispatch.py`, all passing
- Dead letter regression guard passes (dead_letter=0 assertion in integration test)
- No existing tests broken by the Plan 01 changes to `src/queue/worker.py`
- R4.2 (git post-commit capture works end-to-end through queue) — confirmed by Flow3 test
- R4.3 (background processing routes correctly for all job types) — confirmed by dispatch tests
</success_criteria>

<output>
After completion, create `.planning/phases/8.3-gap-closure-queue-dispatch-inserted/8.3-02-SUMMARY.md`
with the list of tests created, pass/fail counts, and confirmation that the dead letter
regression guard is in place.
</output>
