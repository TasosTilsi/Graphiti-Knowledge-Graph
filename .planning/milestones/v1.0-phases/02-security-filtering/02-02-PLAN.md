---
phase: 02-security-filtering
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/security/__init__.py
  - src/security/exclusions.py
  - src/security/audit.py
autonomous: true

must_haves:
  truths:
    - "Files matching exclusion patterns are identified before content processing"
    - "Symlinks are resolved to prevent bypass attacks"
    - "All sanitization events are logged in JSON format"
    - "Audit logs rotate to prevent disk exhaustion"
  artifacts:
    - path: "src/security/exclusions.py"
      provides: "File exclusion logic with symlink resolution"
      exports: ["is_excluded_file", "FileExcluder"]
    - path: "src/security/audit.py"
      provides: "Structured audit logging with rotation"
      exports: ["SecurityAuditLogger", "log_sanitization_event"]
    - path: "src/security/__init__.py"
      provides: "Security package initialization"
  key_links:
    - from: "src/security/exclusions.py"
      to: "src/config/security.py"
      via: "imports DEFAULT_FILE_EXCLUSIONS"
      pattern: "from src.config.security import"
    - from: "src/security/audit.py"
      to: "src/config/security.py"
      via: "imports AUDIT_LOG settings"
      pattern: "from src.config.security import"
---

<objective>
Implement file exclusion system and structured audit logging for security events.

Purpose: File exclusions prevent sensitive files from being processed at all (first line of defense). Audit logging ensures all security events are traceable for compliance and debugging.

Output: FileExcluder class with symlink-safe exclusion checking, SecurityAuditLogger with JSON output and rotation.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-security-filtering/02-CONTEXT.md
@.planning/phases/02-security-filtering/02-RESEARCH.md
@src/models/security.py
@src/config/security.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file exclusion system</name>
  <files>src/security/__init__.py, src/security/exclusions.py</files>
  <action>
1. Create src/security/__init__.py as package marker (empty or with __all__).

2. Create src/security/exclusions.py with:

```python
"""File exclusion system for security filtering.

Provides pattern-based file exclusion with symlink resolution
to prevent bypass attacks through symlinked sensitive files.
"""
from pathlib import Path
from typing import Optional
import fnmatch

from src.config.security import DEFAULT_FILE_EXCLUSIONS
from src.models.security import FileExclusionResult


class FileExcluder:
    """Handles file exclusion logic with configurable patterns."""

    def __init__(self, exclusion_patterns: list[str] | None = None):
        """Initialize with exclusion patterns.

        Args:
            exclusion_patterns: List of glob patterns. Uses defaults if None.
        """
        self.patterns = exclusion_patterns or DEFAULT_FILE_EXCLUSIONS

    def check(self, file_path: Path) -> FileExclusionResult:
        """Check if file should be excluded from security scanning.

        Resolves symlinks to prevent bypass attacks where .env
        is accessed through an innocuously-named symlink.

        Args:
            file_path: Path to check

        Returns:
            FileExclusionResult with exclusion status and matched pattern
        """
        # CRITICAL: Resolve symlinks to prevent bypass
        try:
            resolved_path = file_path.resolve()
        except (OSError, RuntimeError):
            # If resolution fails, be conservative and exclude
            return FileExclusionResult(
                file_path=file_path,
                is_excluded=True,
                matched_pattern="<unresolvable_path>"
            )

        path_str = str(resolved_path)
        path_name = resolved_path.name

        for pattern in self.patterns:
            # Handle directory patterns (ending with /)
            if pattern.endswith('/'):
                dir_pattern = pattern.rstrip('/')
                # Check if any parent directory matches
                for parent in resolved_path.parents:
                    if fnmatch.fnmatch(parent.name, dir_pattern):
                        return FileExclusionResult(
                            file_path=file_path,
                            is_excluded=True,
                            matched_pattern=pattern
                        )

            # Handle ** glob patterns
            elif '**' in pattern:
                # Convert **/ to work with fnmatch
                glob_pattern = pattern.replace('**/', '*')
                if fnmatch.fnmatch(path_str, f"*{glob_pattern}") or \
                   fnmatch.fnmatch(path_name, glob_pattern.lstrip('*/')):
                    return FileExclusionResult(
                        file_path=file_path,
                        is_excluded=True,
                        matched_pattern=pattern
                    )

            # Handle simple glob patterns
            else:
                # Match against full path or just filename
                if fnmatch.fnmatch(path_str, f"*{pattern}*") or \
                   fnmatch.fnmatch(path_name, pattern):
                    return FileExclusionResult(
                        file_path=file_path,
                        is_excluded=True,
                        matched_pattern=pattern
                    )

        return FileExclusionResult(
            file_path=file_path,
            is_excluded=False,
            matched_pattern=None
        )


def is_excluded_file(
    file_path: Path,
    exclusion_patterns: list[str] | None = None
) -> bool:
    """Convenience function to check if file is excluded.

    Args:
        file_path: Path to check
        exclusion_patterns: Optional custom patterns

    Returns:
        True if file should be excluded from scanning
    """
    excluder = FileExcluder(exclusion_patterns)
    return excluder.check(file_path).is_excluded
```

Key points:
- ALWAYS resolve symlinks with Path.resolve() before pattern matching
- Handle directory patterns (trailing /) by checking parent directories
- Handle ** glob patterns for recursive matching
- Fail closed: if path resolution fails, exclude the file
  </action>
  <verify>
python -c "
from pathlib import Path
from src.security.exclusions import FileExcluder, is_excluded_file

excluder = FileExcluder()

# Test .env exclusion
assert is_excluded_file(Path('.env')), '.env should be excluded'
assert is_excluded_file(Path('.env.local')), '.env.local should be excluded'

# Test secret file exclusion
assert is_excluded_file(Path('my_secret.txt')), 'secret file should be excluded'
assert is_excluded_file(Path('credentials.json')), 'credential file should be excluded'

# Test normal file not excluded
assert not is_excluded_file(Path('main.py')), 'main.py should not be excluded'
assert not is_excluded_file(Path('README.md')), 'README.md should not be excluded'

print('File exclusions OK')
"
  </verify>
  <done>
FileExcluder class works with default patterns. .env, secret, credential files are excluded. Normal code files pass through. Symlink resolution implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit logging system</name>
  <files>src/security/audit.py, src/security/__init__.py</files>
  <action>
Create src/security/audit.py with structured JSON logging using structlog:

```python
"""Structured audit logging for security events.

All sanitization events are logged in JSON format with rotation
to support compliance, debugging, and security auditing.
"""
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import Optional

import structlog

from src.config.security import (
    AUDIT_LOG_FILENAME,
    AUDIT_LOG_MAX_BYTES,
    AUDIT_LOG_BACKUP_COUNT,
)
from src.models.security import SecretFinding, DetectionType


class SecurityAuditLogger:
    """Handles structured audit logging for security events."""

    _instance: Optional["SecurityAuditLogger"] = None
    _initialized: bool = False

    def __new__(cls, log_dir: Path | None = None):
        """Singleton pattern - one logger per process."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, log_dir: Path | None = None):
        """Initialize audit logger with file rotation.

        Args:
            log_dir: Directory for audit logs. Defaults to .graphiti/
        """
        if self._initialized:
            return
        self._initialized = True

        # Default to project-local .graphiti directory
        self._log_dir = log_dir or Path(".graphiti")
        self._log_dir.mkdir(parents=True, exist_ok=True)
        self._log_path = self._log_dir / AUDIT_LOG_FILENAME

        # Configure stdlib logging handler with rotation
        self._handler = RotatingFileHandler(
            self._log_path,
            maxBytes=AUDIT_LOG_MAX_BYTES,
            backupCount=AUDIT_LOG_BACKUP_COUNT,
        )
        self._handler.setFormatter(logging.Formatter("%(message)s"))

        # Configure structlog
        structlog.configure(
            processors=[
                structlog.stdlib.filter_by_level,
                structlog.stdlib.add_logger_name,
                structlog.stdlib.add_log_level,
                structlog.processors.TimeStamper(fmt="iso"),
                structlog.processors.StackInfoRenderer(),
                structlog.processors.format_exc_info,
                structlog.processors.JSONRenderer(),
            ],
            context_class=dict,
            logger_factory=structlog.stdlib.LoggerFactory(),
            wrapper_class=structlog.stdlib.BoundLogger,
            cache_logger_on_first_use=True,
        )

        # Create the audit logger
        stdlib_logger = logging.getLogger("audit.security")
        stdlib_logger.setLevel(logging.INFO)
        stdlib_logger.addHandler(self._handler)
        stdlib_logger.propagate = False  # Don't bubble to root

        self._logger = structlog.wrap_logger(stdlib_logger)

    def log_secret_detected(
        self,
        finding: SecretFinding,
        action: str,
        placeholder: str | None = None,
    ) -> None:
        """Log a secret detection event.

        Args:
            finding: The detected secret finding
            action: What was done (masked, allowlisted, blocked)
            placeholder: The placeholder used for masking
        """
        self._logger.info(
            "secret_detected",
            event_type="sanitization",
            action=action,
            secret_type=finding.detection_type.name,
            line_number=finding.line_number,
            confidence=finding.confidence,
            entropy_score=finding.entropy_score,
            file_path=finding.file_path,
            placeholder=placeholder,
        )

    def log_file_excluded(
        self,
        file_path: Path,
        matched_pattern: str,
    ) -> None:
        """Log a file exclusion event.

        Args:
            file_path: Path that was excluded
            matched_pattern: The pattern that matched
        """
        self._logger.info(
            "file_excluded",
            event_type="exclusion",
            file_path=str(file_path),
            matched_pattern=matched_pattern,
        )

    def log_allowlist_check(
        self,
        finding_hash: str,
        was_allowed: bool,
        comment: str | None = None,
    ) -> None:
        """Log an allowlist lookup.

        Args:
            finding_hash: Hash of the checked content
            was_allowed: Whether it was on the allowlist
            comment: Allowlist entry comment if present
        """
        self._logger.info(
            "allowlist_check",
            event_type="allowlist",
            finding_hash=finding_hash,
            was_allowed=was_allowed,
            comment=comment,
        )

    @property
    def log_path(self) -> Path:
        """Return the current log file path."""
        return self._log_path


# Module-level convenience function
def get_audit_logger(log_dir: Path | None = None) -> SecurityAuditLogger:
    """Get the singleton audit logger instance.

    Args:
        log_dir: Optional custom log directory

    Returns:
        SecurityAuditLogger instance
    """
    return SecurityAuditLogger(log_dir)


def log_sanitization_event(
    finding: SecretFinding,
    action: str,
    placeholder: str | None = None,
) -> None:
    """Convenience function to log a sanitization event.

    Args:
        finding: The secret finding
        action: Action taken (masked, allowlisted)
        placeholder: Placeholder used for masking
    """
    get_audit_logger().log_secret_detected(finding, action, placeholder)
```

Update src/security/__init__.py to export:
- FileExcluder, is_excluded_file from exclusions
- SecurityAuditLogger, get_audit_logger, log_sanitization_event from audit
  </action>
  <verify>
python -c "
from pathlib import Path
import tempfile
import json

from src.security.audit import SecurityAuditLogger, get_audit_logger, log_sanitization_event
from src.models.security import SecretFinding, DetectionType

# Test with temp directory
with tempfile.TemporaryDirectory() as tmpdir:
    logger = SecurityAuditLogger(Path(tmpdir))

    # Log a test event
    finding = SecretFinding(
        detection_type=DetectionType.AWS_KEY,
        matched_text='AKIAIOSFODNN7EXAMPLE',
        line_number=42,
        confidence='high',
    )
    logger.log_secret_detected(finding, action='masked', placeholder='[REDACTED:aws_key]')

    # Verify log file exists and contains JSON
    log_path = Path(tmpdir) / 'audit.log'
    assert log_path.exists(), 'Audit log should exist'

    content = log_path.read_text()
    assert 'secret_detected' in content, 'Should contain event'
    assert 'AWS_KEY' in content, 'Should contain secret type'

print('Audit logging OK')
"
  </verify>
  <done>
SecurityAuditLogger works with JSON output and file rotation. Events include timestamp, secret type, action, line number. Logs stored in .graphiti/audit.log with 10MB rotation.
  </done>
</task>

</tasks>

<verification>
- [ ] `from src.security.exclusions import FileExcluder, is_excluded_file` works
- [ ] `from src.security.audit import SecurityAuditLogger, log_sanitization_event` works
- [ ] .env files are excluded
- [ ] Audit log creates JSON entries
- [ ] Audit log rotation configured (10MB, 5 backups)
</verification>

<success_criteria>
Plan complete when:
1. FileExcluder correctly identifies files matching exclusion patterns
2. Symlinks are resolved before pattern matching
3. SecurityAuditLogger writes JSON events with rotation
4. All security package exports work
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-filtering/02-02-SUMMARY.md`
</output>
