---
phase: 8.5-gap-closure-human-runtime-verification-inserted
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md
autonomous: true
requirements:
  - R3.1
  - R3.2
  - R3.3
gap_closure: true

must_haves:
  truths:
    - "A HUMAN-VERIFICATION.md exists in the Phase 02 directory with numbered, runnable test cases"
    - "Each test case has exact CLI commands the human can copy-paste"
    - "Each test case has explicit expected output showing what pass looks like"
    - "The guide is self-contained — human needs no source code knowledge to follow it"
    - "The guide instructs how to update 02-VERIFICATION.md status after passing"
  artifacts:
    - path: ".planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md"
      provides: "Step-by-step human verification guide for security filtering runtime behavior"
      min_lines: 120
  key_links:
    - from: "02-HUMAN-VERIFICATION.md"
      to: ".planning/phases/02-security-filtering/02-VERIFICATION.md"
      via: "update instructions at end of guide"
      pattern: "update.*status.*passed"
---

<objective>
Write the human verification guide for Phase 02 (Security Filtering).

Phase 02 has `status: human_needed` in its VERIFICATION.md. The static verifier confirmed all code
is present and wired, but runtime behavior (test suite execution, actual secret detection, audit
log writing) requires a human with the live environment.

This plan writes `.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md` — a
self-contained step-by-step guide a human can follow to confirm R3.1, R3.2, and R3.3 in
a live environment. After the human completes all tests, they update the VERIFICATION.md
status from `human_needed` to `passed`.

Purpose: Close the verification gap for R3.1 (file exclusions), R3.2 (entity sanitization),
R3.3 (pre-commit validation) by providing a runnable checklist with copy-pasteable commands
and explicit pass/fail criteria.

Output: `.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md`
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-security-filtering/02-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Phase 02 HUMAN-VERIFICATION.md</name>
  <files>.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md</files>
  <action>
Write the file `.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md` with the
exact content below. Do not summarize or abbreviate — write the full content verbatim.

The file content to write:

---

# Phase 02: Security Filtering — Human Verification Guide

**Phase goal:** Confirm that the security filtering system (R3.1, R3.2, R3.3) behaves correctly
at runtime in a live environment.

**Status of automated verification:** All 5 observable truths verified through code analysis.
All code artifacts present and wired. This guide covers what automated verification cannot do:
running the test suite, measuring actual detection behavior, and confirming audit log output.

**Requirements under test:**
- R3.1: File-Level Exclusions — `.env`, secret files, credential files never processed
- R3.2: Entity-Level Sanitization — AWS keys, GitHub tokens, JWTs detected and masked with `[REDACTED:type]`
- R3.3: Pre-Commit Validation — Sanitization events recorded in audit log

---

## Prerequisites

Before running any tests, confirm:

```bash
# 1. Virtual environment is active
which python
# Expected: path ending in .venv/bin/python

# 2. graphiti package is installed
python -c "import src.security; print('OK')"
# Expected: OK

# 3. Dependencies are installed
python -c "import detect_secrets; import structlog; print('OK')"
# Expected: OK
# If this fails: pip install -e '.[dev]'

# 4. Working directory is the project root
ls src/security/
# Expected: __init__.py  allowlist.py  audit.py  detector.py  exclusions.py  patterns.py  sanitizer.py
```

---

## Test 1: Run the Full Test Suite

**What this tests:** All 46 unit and integration tests for security filtering components.

**Commands:**

```bash
cd /home/tasostilsi/Development/Projects/graphiti-knowledge-graph
source .venv/bin/activate
pytest tests/test_security.py -v
```

**Expected output:**

```
tests/test_security.py::TestFileExclusions::test_env_file_excluded PASSED
tests/test_security.py::TestFileExclusions::test_env_local_excluded PASSED
tests/test_security.py::TestFileExclusions::test_env_production_excluded PASSED
tests/test_security.py::TestFileExclusions::test_secrets_json_excluded PASSED
tests/test_security.py::TestFileExclusions::test_private_key_excluded PASSED
tests/test_security.py::TestSecretDetection::...
...
46 passed in X.XXs
```

The final line must be: `46 passed` (no failures, no errors).

**Pass criteria:** `46 passed` — zero failures, zero errors.

**If it fails:** Check which tests fail. Run the failed test individually with `-v -s` for full output:
```bash
pytest tests/test_security.py::TestFileExclusions::test_env_file_excluded -v -s
```

---

## Test 2: AWS Key Detection

**What this tests:** R3.2 — Secret detection and redaction with typed placeholders.

**Commands:**

```bash
python3 -c "
from src.security import sanitize_content

# Test AWS key detection
aws_content = 'AWS_ACCESS_KEY_ID = \"AKIAIOSFODNN7EXAMPLE\"'
result = sanitize_content(aws_content)
print('=== AWS Key Test ===')
print(f'Input:     {aws_content}')
print(f'Output:    {result.sanitized_content}')
print(f'Modified:  {result.was_modified}')
print(f'Findings:  {len(result.findings)}')
if result.findings:
    print(f'Type:      {result.findings[0].detection_type}')
print()

# Test safe content (should not trigger)
safe_content = 'app_name = \"MyApp\"\nversion = \"1.0.0\"\ndebug = False'
result2 = sanitize_content(safe_content)
print('=== Safe Content Test ===')
print(f'Input:     {safe_content!r}')
print(f'Modified:  {result2.was_modified}')
print(f'Findings:  {len(result2.findings)}')
"
```

**Expected output:**

```
=== AWS Key Test ===
Input:     AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
Output:    AWS_ACCESS_KEY_ID = "[REDACTED:aws_key]"
Modified:  True
Findings:  1
Type:      DetectionType.AWS_KEY

=== Safe Content Test ===
Input:     'app_name = "MyApp"\nversion = "1.0.0"\ndebug = False'
Modified:  False
Findings:  0
```

**Pass criteria:**
- AWS key content: `Modified: True`, output contains `[REDACTED:aws_key]`, at least 1 finding
- Safe content: `Modified: False`, `Findings: 0`

---

## Test 3: .env File Exclusion

**What this tests:** R3.1 — Files matching exclusion patterns are never processed.

**Commands:**

```bash
python3 -c "
from pathlib import Path
from src.security import is_excluded_file, ContentSanitizer

print('=== File Exclusion Tests ===')
test_cases = [
    ('.env',               True,  'env file'),
    ('.env.local',         True,  'env.local file'),
    ('.env.production',    True,  'env.production file'),
    ('secrets.json',       True,  'secrets.json file'),
    ('private.key',        True,  'private key file'),
    ('credentials.yaml',   True,  'credentials file'),
    ('api_token.txt',      True,  'token file'),
    ('README.md',          False, 'readme file'),
    ('main.py',            False, 'python source file'),
    ('config.toml',        False, 'config file'),
    ('src/service.py',     False, 'nested source file'),
]

passed = 0
failed = 0
for filename, should_exclude, description in test_cases:
    result = is_excluded_file(Path(filename))
    ok = result == should_exclude
    status = 'PASS' if ok else 'FAIL'
    if ok:
        passed += 1
    else:
        failed += 1
    print(f'  [{status}] {filename!s:30s} excluded={result} (expected {should_exclude}) — {description}')

print()
print(f'Result: {passed} passed, {failed} failed')
"
```

**Expected output:**

```
=== File Exclusion Tests ===
  [PASS] .env                           excluded=True (expected True) — env file
  [PASS] .env.local                     excluded=True (expected True) — env.local file
  [PASS] .env.production                excluded=True (expected True) — env.production file
  [PASS] secrets.json                   excluded=True (expected True) — secrets.json file
  [PASS] private.key                    excluded=True (expected True) — private key file
  [PASS] credentials.yaml              excluded=True (expected True) — credentials file
  [PASS] api_token.txt                  excluded=True (expected True) — token file
  [PASS] README.md                      excluded=False (expected False) — readme file
  [PASS] main.py                        excluded=False (expected False) — python source file
  [PASS] config.toml                    excluded=False (expected False) — config file
  [PASS] src/service.py                 excluded=False (expected False) — nested source file

Result: 11 passed, 0 failed
```

**Pass criteria:** `11 passed, 0 failed`

---

## Test 4: High-Entropy String Detection

**What this tests:** R3.2 — High-entropy strings (generic API keys, tokens) detected even without
a known format.

**Commands:**

```bash
python3 -c "
from src.security import sanitize_content

# High-entropy base64-like string (simulates a generic API key)
# This string has high Shannon entropy and no specific format
high_entropy_content = 'API_TOKEN=aZ9kP2mXvQ8nRwL4jYbC7sEtGhFuIdK'
result = sanitize_content(high_entropy_content)
print('=== High-Entropy Detection ===')
print(f'Input:     {high_entropy_content}')
print(f'Output:    {result.sanitized_content}')
print(f'Modified:  {result.was_modified}')
print(f'Findings:  {len(result.findings)}')
"
```

**Expected output — variant A (detected):**

```
=== High-Entropy Detection ===
Input:     API_TOKEN=aZ9kP2mXvQ8nRwL4jYbC7sEtGhFuIdK
Output:    API_TOKEN=[REDACTED:high_entropy]
Modified:  True
Findings:  1
```

**Expected output — variant B (not detected, entropy below threshold):**

```
=== High-Entropy Detection ===
Input:     API_TOKEN=aZ9kP2mXvQ8nRwL4jYbC7sEtGhFuIdK
Output:    API_TOKEN=aZ9kP2mXvQ8nRwL4jYbC7sEtGhFuIdK
Modified:  False
Findings:  0
```

**Pass criteria:** Either variant A or B is acceptable. The aggressive entropy thresholds
(BASE64=3.5, HEX=2.5) catch most API keys. If variant B occurs, try a longer, more random
string:

```bash
python3 -c "
from src.security import sanitize_content
# A clearly high-entropy base64 string
content = 'TOKEN=dGVzdC1zZWNyZXQta2V5LXZhbHVlLTEyMzQ1Njc4OTAtYWJjZGVmZ2hpamts'
result = sanitize_content(content)
print(f'Modified: {result.was_modified}, Findings: {len(result.findings)}')
if result.was_modified:
    print(f'Output: {result.sanitized_content}')
"
```

**Pass criteria for extended test:** `Modified: True` — the base64-encoded string must be caught.

---

## Test 5: Audit Log Writing

**What this tests:** R3.3 — All sanitization events are recorded in the audit log with JSON format.

**Commands:**

```bash
# Step 1: Create an isolated test directory
mkdir -p /tmp/graphiti_audit_test/.graphiti

# Step 2: Run sanitization with project root
python3 -c "
from pathlib import Path
from src.security import ContentSanitizer

project_root = Path('/tmp/graphiti_audit_test')
sanitizer = ContentSanitizer(project_root=project_root)

content = 'AWS_KEY = \"AKIAIOSFODNN7EXAMPLE\"'
result = sanitizer.sanitize(content, file_path='config.py')

print(f'Sanitized: {result.was_modified}')
print(f'Findings:  {len(result.findings)}')
print(f'Output:    {result.sanitized_content}')
"

# Step 3: Check audit log was created with JSON content
echo ""
echo "=== Audit Log Contents ==="
ls -la /tmp/graphiti_audit_test/.graphiti/
cat /tmp/graphiti_audit_test/.graphiti/audit.log

# Step 4: Cleanup
rm -rf /tmp/graphiti_audit_test
```

**Expected output:**

```
Sanitized: True
Findings:  1
Output:    AWS_KEY = "[REDACTED:aws_key]"

=== Audit Log Contents ===
total 12
drwxr-xr-x 2 user user 4096 Feb 24 10:00 .
drwxr-xr-x 3 user user 4096 Feb 24 10:00 ..
-rw-r--r-- 1 user user  XXX Feb 24 10:00 audit.log
{"event": "secret_detected", "file_path": "config.py", "detection_type": "...", "timestamp": "...", ...}
```

**Pass criteria:**
- Sanitization returns `Modified: True` with 1 finding
- `/tmp/graphiti_audit_test/.graphiti/audit.log` is created
- Audit log contains at least one JSON line with `"event": "secret_detected"`

---

## Test 6: Custom Exclusion Patterns

**What this tests:** R3.1 — Custom exclusion patterns can be added to block additional files.

**Commands:**

```bash
python3 -c "
from pathlib import Path
from src.security import FileExcluder

# Custom patterns that add to the defaults
custom_patterns = ['*.internal', '*_private*', 'company_secrets/']
excluder = FileExcluder(exclusion_patterns=custom_patterns)

print('=== Custom Exclusion Pattern Tests ===')
test_cases = [
    ('database.internal',              True,  'custom *.internal pattern'),
    ('my_private_config.yaml',         True,  'custom *_private* pattern'),
    ('public_config.yaml',             False, 'normal config not excluded'),
    ('main.py',                        False, 'python file not excluded'),
]

passed = 0
failed = 0
for filename, should_exclude, description in test_cases:
    result = excluder.check(Path(filename)).is_excluded
    ok = result == should_exclude
    status = 'PASS' if ok else 'FAIL'
    if ok: passed += 1
    else: failed += 1
    print(f'  [{status}] {filename!s:35s} excluded={result} (expected {should_exclude}) — {description}')

print()
print(f'Result: {passed} passed, {failed} failed')
"
```

**Expected output:**

```
=== Custom Exclusion Pattern Tests ===
  [PASS] database.internal               excluded=True (expected True) — custom *.internal pattern
  [PASS] my_private_config.yaml          excluded=True (expected True) — custom *_private* pattern
  [PASS] public_config.yaml              excluded=False (expected False) — normal config not excluded
  [PASS] main.py                         excluded=False (expected False) — python file not excluded

Result: 4 passed, 0 failed
```

**Pass criteria:** `4 passed, 0 failed`

---

## Overall Pass Criteria

All 6 tests must pass:

| # | Test | Pass Condition |
|---|------|----------------|
| 1 | Full test suite | `46 passed` — zero failures |
| 2 | AWS key detection | `Modified: True`, output contains `[REDACTED:aws_key]` |
| 3 | .env file exclusion | `11 passed, 0 failed` |
| 4 | High-entropy detection | `Modified: True` for base64-encoded string |
| 5 | Audit log writing | `audit.log` created with JSON `secret_detected` event |
| 6 | Custom exclusion patterns | `4 passed, 0 failed` |

---

## After Passing: Update VERIFICATION.md

Once all 6 tests pass, update the Phase 02 VERIFICATION.md status:

1. Open `.planning/phases/02-security-filtering/02-VERIFICATION.md`

2. Change the frontmatter `status` field:
   ```yaml
   # Before:
   status: human_needed

   # After:
   status: passed
   ```

3. Add a `human_verified` date field below `verified`:
   ```yaml
   verified: 2026-02-04T09:15:00Z
   human_verified: YYYY-MM-DDTHH:MM:SSZ   # today's date and time
   status: passed
   ```

4. At the bottom of the file, add a section:
   ```markdown
   ### Human Verification Result

   **Verified by:** [Your name or "Human tester"]
   **Date:** YYYY-MM-DD
   **All tests passed:** Yes

   | Test | Result |
   |------|--------|
   | Test 1: Full test suite | 46 passed |
   | Test 2: AWS key detection | PASS |
   | Test 3: .env file exclusion | 11/11 PASS |
   | Test 4: High-entropy detection | PASS |
   | Test 5: Audit log writing | PASS |
   | Test 6: Custom exclusion patterns | 4/4 PASS |

   **Requirements closed:** R3.1, R3.2, R3.3
   ```

5. Save the file. Phase 02 verification is now complete.

---

_Guide written: 2026-02-24_
_Phase: 02-security-filtering_
_Requirements: R3.1, R3.2, R3.3_
  </action>
  <verify>
Check that the file exists and has the required sections:

```bash
ls -la .planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md
grep -c "Test [0-9]:" .planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md
grep "Pass criteria" .planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md | wc -l
grep "Update VERIFICATION.md" .planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md
```

Expected: file exists, at least 6 "Test N:" occurrences, at least 5 "Pass criteria" lines,
"Update VERIFICATION.md" section present.
  </verify>
  <done>
`.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md` exists with:
- 6 numbered test cases (Test 1 through Test 6)
- Copy-pasteable commands for every test
- Explicit expected output with pass/fail criteria
- Instructions to update 02-VERIFICATION.md status after passing
  </done>
</task>

</tasks>

<verification>
The plan is complete when:
- `.planning/phases/02-security-filtering/02-HUMAN-VERIFICATION.md` exists on disk
- File contains 6 test cases with runnable commands
- File contains "After Passing: Update VERIFICATION.md" section
- A human following the guide can confirm R3.1, R3.2, R3.3 without reading source code
</verification>

<success_criteria>
1. Phase 02 HUMAN-VERIFICATION.md exists with numbered, runnable test cases
2. Each test has exact commands, expected output, and explicit pass criteria
3. The guide is fully self-contained — no source code knowledge required
4. Final section instructs how to update 02-VERIFICATION.md from human_needed to passed
</success_criteria>

<output>
After completion, create `.planning/phases/8.5-gap-closure-human-runtime-verification-inserted/8.5-01-SUMMARY.md`
</output>
