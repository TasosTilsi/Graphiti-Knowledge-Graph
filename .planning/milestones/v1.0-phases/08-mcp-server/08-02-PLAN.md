---
phase: 08-mcp-server
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp_server/tools.py
autonomous: true
requirements:
  - R6.1
  - R6.3

must_haves:
  truths:
    - "All 10 CLI commands are exposed as graphiti_* MCP tools via subprocess"
    - "Tools return TOON-encoded output for array results, plain text for scalar results"
    - "graphiti_capture uses Popen (non-blocking) not subprocess.run (blocking)"
    - "Tool errors raise RuntimeError with actionable stderr message (not silent failure)"
    - "Subprocess calls always pass cwd= from the GRAPHITI_PROJECT_ROOT env var or CWD"
  artifacts:
    - path: "src/mcp_server/tools.py"
      provides: "10 graphiti_* tool handler functions callable by FastMCP"
      min_lines: 150
      exports:
        - "graphiti_add"
        - "graphiti_search"
        - "graphiti_list"
        - "graphiti_show"
        - "graphiti_delete"
        - "graphiti_summarize"
        - "graphiti_compact"
        - "graphiti_capture"
        - "graphiti_health"
        - "graphiti_config"
  key_links:
    - from: "src/mcp_server/tools.py"
      to: "graphiti CLI"
      via: "subprocess.run(['graphiti', cmd, ...], capture_output=True, text=True)"
      pattern: "subprocess\\.run.*graphiti"
    - from: "src/mcp_server/tools.py"
      to: "src/mcp_server/toon_utils.py"
      via: "encode_response(data)"
      pattern: "from src.mcp_server.toon_utils import encode_response"
    - from: "graphiti_capture"
      to: "subprocess.Popen"
      via: "non-blocking launch with --async flag"
      pattern: "subprocess\\.Popen"
---

<objective>
Implement all 10 MCP tool handler functions that wrap the graphiti CLI via subprocess. Each function is a plain Python callable that execute-phase will register with FastMCP using @mcp.tool() decorators in Plan 03.

Purpose: Tools are the primary interface Claude Code uses to read and write the knowledge graph. They must be reliable (raise on non-zero exit), performant (respect CWD for scope detection), and non-blocking for capture operations.

Output: src/mcp_server/tools.py with 10 functions ready to be registered as FastMCP tools.
</objective>

<execution_context>
@/home/tasostilsi/.claude/get-shit-done/workflows/execute-plan.md
@/home/tasostilsi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-mcp-server/08-CONTEXT.md
@.planning/phases/08-mcp-server/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement _run_graphiti helper and 5 read-oriented tools</name>
  <files>src/mcp_server/tools.py</files>
  <action>
Create `src/mcp_server/tools.py`. All logging in this file MUST go to stderr only — never stdout — because stdio transport uses stdout for JSON-RPC. Add `import logging; logging.basicConfig(stream=sys.stderr, level=logging.WARNING)` at the module top. Do NOT import Rich console, structlog, or any library that writes to stdout on import.

**Module-level imports (only these):**
```python
import json
import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)
```

**_run_graphiti(args, timeout, cwd) helper:**
```python
def _run_graphiti(args: list[str], timeout: int = 30, cwd: str | None = None) -> tuple[int, str, str]:
    """Run graphiti CLI and return (returncode, stdout, stderr)."""
    # CWD for scope detection: use GRAPHITI_PROJECT_ROOT env var if set,
    # else the provided cwd, else inherit from process (which is Claude Code's CWD)
    effective_cwd = os.environ.get("GRAPHITI_PROJECT_ROOT") or cwd
    result = subprocess.run(
        ["graphiti"] + args,
        capture_output=True,
        text=True,
        timeout=timeout,
        cwd=effective_cwd,
    )
    return result.returncode, result.stdout, result.stderr
```

**_get_cwd() helper:**
```python
def _get_cwd() -> str | None:
    """Get project CWD for subprocess calls (scope detection)."""
    return os.environ.get("GRAPHITI_PROJECT_ROOT") or None
```

**Implement these 5 read tools as plain functions (no decorators — decorators go in server.py):**

`graphiti_search(query: str, limit: int = 10, exact: bool = False, scope: str = "auto") -> str`:
- Run: `graphiti search <query> --limit <limit> --format json` plus `--exact` if exact=True, `--global` if scope=="global", `--project` if scope=="project"
- Parse JSON stdout, call `encode_response(data)` from toon_utils
- Raise RuntimeError if returncode != 0: `f"graphiti search failed: {stderr.strip()}"`
- Return TOON/JSON encoded result

`graphiti_list(limit: int = 15, scope: str = "auto") -> str`:
- Run: `graphiti list --limit <limit> --format json` plus scope flags
- Parse and encode like search

`graphiti_show(name_or_id: str) -> str`:
- Run: `graphiti show <name_or_id> --format json`
- Single result — `encode_response(data)` returns JSON (not TOON, single item)
- Raise RuntimeError on non-zero exit

`graphiti_summarize(scope: str = "auto") -> str`:
- Run: `graphiti summarize --format json` plus scope flags
- Returns a summary dict — encode as JSON (single object response)
- Raise RuntimeError on non-zero exit

`graphiti_health() -> str`:
- Run: `graphiti health --format json`
- Returns health status dict — return plain text stdout (no TOON for status)
- On non-zero exit: return the stderr as a warning string (not raise — health check failure is informational)

Import `encode_response` from `src.mcp_server.toon_utils` with a try/except fallback to json.dumps in case Plan 01 hasn't been executed yet:
```python
try:
    from src.mcp_server.toon_utils import encode_response
except ImportError:
    def encode_response(data): return json.dumps(data, indent=2)
```
  </action>
  <verify>
Run: `python -c "from src.mcp_server.tools import graphiti_search, graphiti_list, graphiti_show, graphiti_summarize, graphiti_health; print('5 read tools OK')"` — must print "5 read tools OK".

Run: `python -c "from src.mcp_server import tools; import inspect; funcs = [f for f in dir(tools) if f.startswith('graphiti_')]; print(funcs)"` — must list at least the 5 functions.
  </verify>
  <done>5 read tools importable. _run_graphiti and _get_cwd helpers implemented. No stdout logging. encode_response imported with ImportError fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Implement 5 write/action tools including non-blocking capture</name>
  <files>src/mcp_server/tools.py</files>
  <action>
Add the remaining 5 tool functions to src/mcp_server/tools.py:

`graphiti_add(content: str, tags: str = "", scope: str = "auto") -> str`:
- Build cmd: `["graphiti", "add", content]`
- If tags: append `["--tags", tags]`
- If scope == "global": append `["--global"]`; if scope == "project": append `["--project"]`
- Run with `_run_graphiti(cmd, timeout=60, cwd=_get_cwd())`
- Raise RuntimeError on non-zero exit: `f"graphiti add failed: {stderr.strip()}"`
- Return `stdout.strip() or "Knowledge added successfully."`

`graphiti_delete(name_or_id: str, force: bool = True) -> str`:
- Build cmd: `["graphiti", "delete", name_or_id]`
- Always pass `--force` (MCP callers don't have interactive TTY for confirmation)
- Run with `_run_graphiti(cmd, timeout=30, cwd=_get_cwd())`
- Raise RuntimeError on non-zero exit
- Return `stdout.strip() or "Entity deleted."`

`graphiti_compact(scope: str = "auto") -> str`:
- Build cmd: `["graphiti", "compact"]` plus scope flags
- Run with `_run_graphiti(cmd, timeout=120, cwd=_get_cwd())` — compact can be slow
- Raise RuntimeError on non-zero exit
- Return `stdout.strip() or "Knowledge graph compacted."`

`graphiti_capture() -> str`:
- **CRITICAL: Non-blocking.** Use `subprocess.Popen` NOT `subprocess.run`.
- Capture operations involve LLM summarization — can take 5-30s. Must return immediately.
- Implementation:
  ```python
  def graphiti_capture() -> str:
      """Capture current conversation context into the knowledge graph.

      Runs asynchronously — returns immediately without waiting for completion.
      """
      cwd = _get_cwd()
      try:
          subprocess.Popen(
              ["graphiti", "capture", "--async"],
              stdout=subprocess.DEVNULL,
              stderr=subprocess.DEVNULL,
              start_new_session=True,
              cwd=cwd,
          )
          return "Conversation capture started in background."
      except FileNotFoundError:
          raise RuntimeError("graphiti CLI not found. Run 'pip install graphiti-knowledge-graph' to install.")
      except Exception as e:
          raise RuntimeError(f"Failed to start capture: {e}")
  ```
- Use `start_new_session=True` to detach the subprocess from the MCP server process (prevents zombie on exit).
- Redirect both stdout and stderr to DEVNULL — the background process should not inherit the stdio transport's file descriptors.

`graphiti_config(key: str, value: str = "") -> str`:
- If value is empty: run `graphiti config get <key>`
- If value is non-empty: run `graphiti config set <key> <value>`
- Run with `_run_graphiti(cmd, timeout=10, cwd=_get_cwd())`
- Raise RuntimeError on non-zero exit
- Return `stdout.strip()`

After implementing all 10 functions, add `__all__` at the bottom:
```python
__all__ = [
    "graphiti_add",
    "graphiti_search",
    "graphiti_list",
    "graphiti_show",
    "graphiti_delete",
    "graphiti_summarize",
    "graphiti_compact",
    "graphiti_capture",
    "graphiti_health",
    "graphiti_config",
]
```
  </action>
  <verify>
Run: `python -c "from src.mcp_server.tools import graphiti_add, graphiti_delete, graphiti_compact, graphiti_capture, graphiti_config; print('5 write tools OK')"` — must print "5 write tools OK".

Run: `python -c "from src.mcp_server import tools; print(sorted([f for f in dir(tools) if f.startswith('graphiti_')]))"` — must list all 10 graphiti_* functions.

Run: `python -c "import subprocess; from src.mcp_server.tools import graphiti_capture; import inspect; src = inspect.getsource(graphiti_capture); assert 'Popen' in src, 'Must use Popen not run'; assert 'DEVNULL' in src, 'Must redirect to DEVNULL'; print('non-blocking OK')"` — must print "non-blocking OK".
  </verify>
  <done>All 10 graphiti_* tool functions implemented. graphiti_capture uses Popen with DEVNULL and start_new_session=True. All functions raise RuntimeError with actionable message on failure. __all__ declares all 10 exports.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `python -c "from src.mcp_server.tools import *; print([f for f in dir() if f.startswith('graphiti_')])"` — lists all 10 tools
2. `grep -c "def graphiti_" src/mcp_server/tools.py` — outputs 10
3. `grep "subprocess.Popen" src/mcp_server/tools.py` — confirms non-blocking capture
4. `grep -n "print\|console\|structlog" src/mcp_server/tools.py` — must show NO stdout writes (only `logger.` calls acceptable)
5. `grep "GRAPHITI_PROJECT_ROOT" src/mcp_server/tools.py` — confirms scope-aware CWD handling
</verification>

<success_criteria>
- All 10 tool functions importable from src.mcp_server.tools
- graphiti_capture uses subprocess.Popen (non-blocking), not subprocess.run
- All write tools (add, delete, compact) raise RuntimeError on non-zero exit
- graphiti_health returns info even on non-zero exit (health failure is informational)
- No stdout writes anywhere in the module (stdio transport safety)
- CWD handling uses GRAPHITI_PROJECT_ROOT env var as override for project scope detection
</success_criteria>

<output>
After completion, create `.planning/phases/08-mcp-server/08-02-SUMMARY.md` with:
- All 10 tool signatures with their subprocess commands
- Notes on non-blocking capture implementation
- CWD/scope detection approach
- Verification output
</output>
